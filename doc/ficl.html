<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="john sadler">
    <meta name="description" content="Ficl - embedded scripting with object oriented programming">
    <link rel="icon" href="ficl-icon.svg" type="image/svg+xml">
    <link rel="stylesheet" href="styles.css">
    <title>Ficl - Embedded Scripting</title>
  </head>
  <body>
    <header class="site-header">
      <div class="wrap">
        <a class="brand" href="index.html">
          <img class="brand-mark" src="ficl-icon.svg" alt="Ficl logo">
          <div>
            <span class="brand-name">Ficl</span>
            <span class="brand-tag">Forth Inspired Command Language</span>
          </div>
        </a>
        <nav class="site-nav">
          <a href="ficl.html">Docs</a>
          <a href="demo.html">Demo</a>
          <a href="ficl_rel.html">Release Notes</a>
          <a class="nav-cta" href="http://sourceforge.net/project/showfiles.php?group_id=24441">Download</a>
        </nav>
      </div>
    </header>

    <main>
      <section class="page-hero">
        <div class="wrap">
          <p class="eyebrow">Documentation</p>
          <h1>Ficl Documentation</h1>
          <p>Core reference, features, and API details.</p>
        </div>
      </section>

      <div class="docs-layout">
      <nav class="toc-sidebar" id="toc-sidebar">
        <div class="toc-title">Contents</div>
        <ul>
          <li><a href="#whatis">About</a></li>
          <li><a href="#links">References</a></li>
          <li><a href="#lawyerbait">License</a></li>
          <li><a href="#porting">Porting</a></li>
          <li><a href="#api">API</a></li>
          <li><a href="#manifest">Source Files</a></li>
          <li><a href="#internals">Internals</a></li>
          <li><a href="#extras">Extras</a></li>
          <li><a href="#locals">Local Variables</a></li>
          <li><a href="#oop">OOP</a></li>
          <li><a href="#parsesteps">Parse Steps</a></li>
          <li><a href="#debugger">Debugger</a></li>
          <li><a href="#ansinfo">ANS Info</a></li>
        </ul>
      </nav>
      <div class="content">

      <H1>
        <A name="whatis"></A>What is ficl?
      </H1>
      <P>
        Ficl is a lightweight, embeddable scripting language designed to be incorporated
        into other programs, including memory constrained embedded systems.
        Ficl conforms to the 1994 ANSI Standard for Forth, and provides several useful
        extensions including OOP that can wrap compiled code and hardware interfaces.&nbsp;
      </P>
      <P>
        Unlike Lua or Python, Ficl acts as a <I>component</I> of your system: you feed it stuff to do, it does the stuff, and comes back to you for more.
        You can export compiled code to Ficl, execute Ficl code from your compiled code, or interact with a read-execute-print loop.
        Your choice.
        Ficl includes a simple but capable object model that can wrap existing data structures.&nbsp;
      </P>
      <H3>
        Ficl vs. other Interpreters
      </H3>
      Where language interpreters usually view themselves as the center of the system, Ficl acts as a component of the system. It is easy to export compiled code
      to Ficl in the style of TCL, or to invoke Ficl code from a compiled module. This allows you to do incremental development in a way that combines the best features of
      threaded languages (rapid development, quick code/test/debug cycle, reasonably fast) with the best features of C (everyone knows it, easier to support large blocks of code, efficient, type
      checking). In addition, Ficl provides a simple and powerful object model that can act as an object oriented <I>adapter</I> for code written in C/C++.&nbsp;
      <H3>
        Ficl Design goals
      </H3>
      <UL>
        <LI>
          Scripting, prototyping, and extension language for systems written also in C/C++
        </LI>
        <LI>
          Target 32 & 64 bit processors, including embedded systems with limited memory
        </LI>
        <LI>
          Wrap functions and data structures written in C/C++
        </LI>
        <LI>
          Conform to the Forth DPANS 94
        </LI>
        <LI>
          Minimize porting effort - require an ANSI C runtime environment and minimal glue code
        </LI>
        <LI>
          Provide Object Oriented extensions that can wrap system functions and structures
        </LI>
      </UL>
      <HR>
      <H2>
        <A name="links"></A>References: More information on Ficl
      </H2>
      <UL>
        <LI>
          <A href="http://ficl.sourceforge.net">Web home of Ficl</A>
        </LI>
        <LI>
          <A href="https://github.com/jwsadler58/ficl">Github Repository</A>
        </LI>
        <LI>
          <A href="demo.html">Try Ficl in your browser</A>
        </LI>
        <LI>
          <A href="oo_in_c.html">OO in C background notes</A>
        </LI>
        <LI>
          <A href="ficlddj.pdf">Manuscript of Ficl article for January 1999 Dr. Dobb's Journal</A>
        </LI>
        <LI>
          <A href="jwsforml.pdf">1998 FORML Conference paper - OO Programming in Ficl</A>
        </LI>
      </UL>
      <H2>
        Forth and Threaded Interpretive Languages
      </H2>
      <UL>
        <LI>
          <A href="https://www.taygeta.com/forth_intro/stackflo.html">An Introduction to Forth using Stack Flow</A> (start here if you're new to Forth)
        </LI>
        <LI>
          <A href="https://www.softsynth.com/pforth/pf_tut.php">Phil Burk's Forth Tutorial</A>
        </LI>
        <LI>
          <A href="https://ficl.sourceforge.net/pdf/Forth_Primer.pdf">An excellent Forth Primer by Hans Bezemer</A>
        </LI>
        <LI>
          <A href="https://www.complang.tuwien.ac.at/forth/threaded-code.html">Anton Ertl's description of Threaded Code</A>
        </LI>
        <LI>
          <A href="https://forth-standard.org/">American National Standard for Forth</A>
        </LI>
        <LI>
          <A href="https://www.taygeta.com/forthlit.html">Forth literature index on Taygeta</A>
        </LI>
        <LI>
          <A href="https://www.forth.org/tutorials.html">Tutorials from Forth Interest Group</A>
        </LI>
      </UL>
      <HR>
      <H2>
        <A name="lawyerbait"></A>LICENSE and DISCLAIMER
      </H2>
      <P>
        Copyright (c) 1997-2026 John Sadler, All rights reserved.
      </P>
      <P>
        I am interested in hearing from anyone who uses ficl. If you have a problem, a success story, a defect, an enhancement request, or if you would like to contribute to a ficl release, please
        contact me on Sourceforge.&nbsp;
      </P>
<PRE>
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. Neither the name of the copyright holder nor the names of its contributors
   may be used to endorse or promote products derived from this software
   without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
</PRE>
      &nbsp;
      <HR>
      <H2>
        <A name="porting"></A>Getting Started: Porting Ficl to your system
      </H2>
      To install ficl on your target system, you need an ANSI C compiler (C11 or newer) and its runtime library.
      System dependent code is isolated to a few functions that you need to implement for your system. See sysdep.h for build controls.&nbsp;
      <P>
        Edit the definitions (in sysdep.c) of <code>ficlMalloc, ficlFree, ficlRealloc</code>, and <code>ficlTextOut</code> for your application and target.
        Use <code>testmain.c</code> as a guide to installing the ficl system and one or more virtual machines into your code.&nbsp;
      </P>
      <P>
        Ficl includes portable double precision math routines that work for 32 and 64 bit machines.
        You may replace them with machine-dependent versions by #defining PORTABLE_LONGMULDIV to 0 in sysdep.h and
        implementing your versions of ficlLongMul and ficlLongDiv in sysdep.c.
        &nbsp;
      </P>
      <H3>
        Build controls
      </H3>
      The file sysdep.h contains default values for build controls. Most of these are written such that if you define them on the compiler command line, the defaults are overridden. I suggest you
      take the defaults on everything below the "build controls" section until you're confident of your port. Beware of declaring too small a dictionary.
      You can use <code>unused</code> and <code>.dict</code> to see how much space is left with a given configuration.&nbsp;
      <H3>
        Softwords
      </H3>
      Many words from the supported wordsets are written in Forth and stored as a big string that Ficl compiles when it starts. The sources for all of these words are in directory
      ficl/softwords. There is a Python 3 script (softcore.py) that converts the .fr files into softcore.c.
      See the makefile in ficl/softwords.&nbsp;
      <HR>
      <H2>
        <A name="api"></A>Application Programming Interface
      </H2>
      The following is a partial listing of functions that interface your system or program to ficl.
      <I>See the comments in ficl.c and ficl.h for additional information, and the example in file testmain.c.</I>
      <DL>
        <DT>
          <B>FICL_SYSTEM *ficlInitSystemEx(FICL_SYSTEM_INFO *fsi)</B>
        </DT>
        <DD>
          Binds a global dictionary to the interpreter system and initializes
          the dict to contain the ANSI CORE wordset.
          You can specify the dictionary size, text output function, and an extension pointer
          via the FICL_SYSTEM_INFO structure.
          After initialization, ficl manages the dictionary.
          The dictionary needs to be at least large enough to hold the
          precompiled part. Try 5K cells to start. Use <code>.dict</code>to find
          out how much of the dictionary is used at any time.
        </DD>
        <DT>
          <B>FICL_SYSTEM *ficlInitSystem(int nDictCells)</B>
        </DT>
        <DD>
          Deprecated. Initializes Ficl's shared system data structures, and creates the dictionary allocating the specified number of CELLs from the heap (by a call to ficlMalloc). Use ficlInitSystemEx for new code.
        </DD>
        <DT>
          <B>void ficlTermSystem(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Deletes the system dictionary and all virtual machines that
          were created with ficlNewVM.
          Call this function to reclaim all memory used by the dictionary and VMs.
          Any uses of the memory allocation words (allocate and resize) are your problem.
        </DD>
        <DT>
          <B>int ficlEvaluate(FICL_VM *pVM, const char *pText)</B>
        </DT>
        <DD>
          Evaluates a block of input text in the context of the
          specified interpreter. Also sets SOURCE-ID properly.
          Use this function when passing a hard-coded
          string to the Ficl interpreter.
        </DD>
        <DT>
          <B>int ficlExec(FICL_VM *pVM, const char *pText)</B>
        </DT>
        <DD>
          Evaluates a block of input text in the context of the
          specified interpreter. Emits any requested output to the
          interpreter's output function. If the input string is NULL
          terminated, you can pass -1 as nChars rather than count it.
          Execution returns when the text block has been executed,
          or an error occurs.
          Returns one of the VM_XXXX codes defined in ficl.h:
          VM_OUTOFTEXT is the normal exit condition.
          VM_ERREXIT means the interpreter encountered a syntax error
          and the VM has been reset to recover.
          VM_USEREXIT means the user executed the "bye" command.
          VM_ABORT and VM_ABORTQ are generated by 'abort' and 'abort"'.
          ficlExec calls can be nested, and the function itself is re-entrant, but note
          that a VM is static, so you have to take reasonable precautions (for example, use one VM per thread in a multithreaded system if you want multiple threads to be able to execute commands).
          If you call ficlExec() or one of its brothers, you MUST
          ensure pVM-&gt;sourceID was set to a sensible value.
          ficlExec() explicitly DOES NOT manage SOURCE-ID for you.
        </DD>
        <DT>
          <B>int ficlExecC(FICL_VM *pVM, const char *pText, FICL_INT nChars)</B>
        </DT>
        <DD>
          Same as ficlExec, but takes a count indicating the length of the supplied string. Setting nChars to -1 is equivalent to ficlExec (expects '\0' termination).
        </DD>
        <DT>
          <B>int ficlExecXT(FICL_VM *pVM, FICL_WORD *pWord)</B>
        </DT>
        <DD>
          Same as ficlExec, but takes a pointer to a FICL_WORD instead of a string. Executes the word and returns after it has finished. If executing the word results in an exception, this function
          will re-throw the same code if it is nested under another ficlExec family function, or return the exception code directly if not. This function is useful if you need to execute the same
          word repeatedly - you save the dictionary search and outer interpreter overhead.
        </DD>
        <DT>
          <B>FICL_VM *ficlNewVM(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Create a new VM from the heap, and link it into the system VM list.
          Initializes the VM and binds default sized stacks to it. Returns the
          address of the VM, or NULL if an error occurs.
        </DD>
        <DT>
          <B>void ficlFreeVM(FICL_VM *pVM)</B>
        </DT>
        <DD>
          Force deletion of a VM. You do not need to do this
          unless you're creating and discarding a lot of VMs.
          For systems that use a constant pool of VMs for the life
          of the system, ficlTermSystem takes care of VM cleanup
          automatically.
        </DD>
        <DT>
          <B>void vmInterrupt(FICL_VM *pVM)</B>
        </DT>
        <DD>
          Interrupt a running VM from an external context such as a signal handler,
          hardware interrupt, watchdog timer ISR, or another thread.
          Causes the VM to longjmp back to the nearest exception recovery point
          with VM_INTERRUPT, which the caller of ficlExec (or ficlExecXT) will
          receive as a return code.
          This is how the console application in testmain.c handles Ctrl-C, for example.
          This is also the recommended way to break out of infinite loops or
          long-running computations (assuming they are coded in Ficl) in embedded systems:
          configure a watchdog orperiodic timer to call vmInterrupt on the active VM,
          and handle the VM_INTERRUPT return code in your outer loop.
          Safe to call from POSIX signal handlers on targets that use siglongjmp.
        </DD>
        <DT>
          <B>int ficlSetStackSize(int nStackCells)</B>
        </DT>
        <DD>
          Set the stack sizes (return and parameter) to be used for all
          subsequently created VMs. Returns actual stack size to be used.
        </DD>
        <DT>
          <B>FICL_WORD *ficlLookup(FICL_SYSTEM *pSys, const char *name)</B>
        </DT>
        <DD>
          Returns the address of the most recently defined word in the system
          dictionary with the given name, or NULL if no match.
          The address is also known as an XT and can be used in a call to ficlExecXT.
        </DD>
        <DT>
          <B>FICL_DICT *ficlGetDict(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Returns a pointer to the main system dictionary, or NULL if the system is uninitialized.
        </DD>
        <DT>
          <B>FICL_HASH *ficlGetEnv(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Returns a pointer to the environment wordlist (FICL_HASH). This wordlist is allocated within the
          main dictionary and stores implementation information as required by the Standard. The returned
          value is a wordlist identifier (wid) that can be added to the search order, enabling direct
          execution of environment constants.
        </DD>
        <DT>
          <B>void ficlSetEnv(FICL_SYSTEM *pSys, const char *name, FICL_UNS value)</B>
        </DT>
        <DD>
          Enters a new constant into the environment wordlist, with the specified name and value.
          The word is allocated in the main dictionary but inserted into the environment wordlist.
        </DD>
        <DT>
          <B>void ficlSetEnvD(FICL_SYSTEM *pSys, const char *name, FICL_UNS hi, FICL_UNS lo)</B>
        </DT>
        <DD>
          Enters a new double-cell constant into the environment wordlist with the specified name and value.
        </DD>
        <DT>
          <B>void ficlSetEnvF(FICL_SYSTEM *pSys, const char *name, FICL_FLOAT f)</B>
        </DT>
        <DD>
          Enters a new floating-point constant into the environment wordlist with the specified name and value. Only available when FICL_WANT_FLOAT is enabled.
        </DD>
        <DT>
          <B>FICL_DICT *ficlGetLoc(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Returns a pointer to the locals dictionary. This function is defined only if FICL_WANT_LOCALS is #defined as non-zero (see sysdep.h). The locals dictionary is the symbol table for <A href=
          "#locals">local variables</A>.
        </DD>
        <DT>
          <B>int ficlBuild(FICL_SYSTEM *pSys, const char *name, FICL_CODE code, char flags)</B>
        </DT>
        <DD>
          Builds a word into the system default dictionary in a thread-safe way.
          Parameters:
          name -- the name of the word to be built;
          code -- code to execute when the word is invoked (must take a single pointer to a FICL_VM);
          flags -- 0 or more of FW_IMMEDIATE, FW_COMPILE, use bitwise OR
          (most words can use FW_DEFAULT).
        </DD>
        <DT>
          <B>void ficlCompileCore(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Builds the ANS CORE wordset into the dictionary - called by
          ficlInitSystem. No need to call it again.
        </DD>
        <DT>
          <B>void ficlCompilePrefix(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Builds the prefix parse step words into the dictionary.
        </DD>
        <DT>
          <B>void ficlCompileSearch(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Builds the SEARCH-ORDER wordset into the dictionary.
        </DD>
        <DT>
          <B>void ficlCompileSoftCore(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Defined in softcore.c, this function builds ANS required words and ficl extras by evaluating a text string. Python3 script softcore.py
          generates the string in softcore.c from .fr files in ficl/softcore.
        </DD>
        <DT>
          <B>void ficlCompileTools(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Builds the TOOLS and TOOLS EXT wordsets into the dictionary.
        </DD>
        <DT>
          <B>void ficlCompileFile(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Builds the File-Access wordset into the dictionary.
        </DD>
        <DT>
          <B>void ficlCompileFloat(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Builds the optional FLOAT wordset into the dictionary. Only available when FICL_WANT_FLOAT is enabled.
        </DD>
        <DT>
          <B>void ficlCompilePlatform(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Builds platform-specific extension words into the dictionary. Only available when FICL_PLATFORM_EXTEND is enabled.
        </DD>
      </DL>
      <HR>
      <TABLE border="0" cellspacing="5" cols="2">
        <TR>
          <TD colspan="2">
            <H2>
              <A name="manifest"></A>Ficl Source Files
            </H2>
          </TD>
        </TR>
        <TR>
          <TD>
            <B>ficl.h</B>
          </TD>
          <TD>
            Declares most public functions and all data structures. Includes sysdep.h and math.h
          </TD>
        </TR>
        <TR>
          <TD>
            <B>sysdep.h</B>
          </TD>
          <TD>
            Declares system dependent functions and contains build control macros. Edit this file to suit your target.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>dpmath.h</B>
          </TD>
          <TD>
            Declares functions for double precision integer math.
            Sizes automatically to 128 bits on a 64 bit machine or 64 bits on a 32 bit machine
          </TD>
        </TR>
        <TR>
          <TD>
            <B>dict.c</B>
          </TD>
          <TD>
            Dictionary
          </TD>
        </TR>
        <TR>
          <TD>
            <B>ficl.c</B>
          </TD>
          <TD>
            System initialization, termination, and ficlExec
          </TD>
        </TR>
        <TR>
          <TD>
            <B>fileaccess.c</B>
          </TD>
          <TD>
            Contains C implementations of the File-Access wordset. Conditioned on FICL_WANT_FILE.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>float.c</B>
          </TD>
          <TD>
            Adds precompiled definitions from the optional FLOAT word set.
            Ficl floats have a dedicated stack and are automatically sized
            to the target machine's register width, unless overridden by defining
            FICL_FLOAT_BITS to 32 or 64 explicitly.
            Most of the file is conditioned on FICL_WANT_FLOAT.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>dpmath.c</B>
          </TD>
          <TD>
            Double precision integer math support, including portable versions of ficlLongMul and ficlLongDiv
          </TD>
        </TR>
        <TR>
          <TD>
            <B>prefix.c</B>
          </TD>
          <TD>
            The optional prefix parse step (conditioned on FICL_EXTENDED_PREFIX). This parse step handles numeric constructs like 0xa100, for example. See the release notes for more on parse steps.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>search.c</B>
          </TD>
          <TD>
            Contains C implementations of several of the SEARCH and SEARCH EXT words
          </TD>
        </TR>
        <TR>
          <TD>
            <B>softcore.c</B>
          </TD>
          <TD>
            Contains all of the "soft" words - those written in Forth and compiled by Ficl at startup time. Sources for these words are in the softwords directory. The Python 3 script
            softwords/softcore.py generates softcore.c from the .fr sources.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>stack.c</B>
          </TD>
          <TD>
            Stack methods
          </TD>
        </TR>
        <TR>
          <TD>
            <B>sysdep.c</B>
          </TD>
          <TD>
            Target dependent functions declared in sysdep.h. Edit this file to suit your target system.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>testmain.c</B>
          </TD>
          <TD>
            The main() function for console applications - use this as an example to integrate ficl into your system.
            Also runs unit tests and adds a few handy OS interface words.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>tools.c</B>
          </TD>
          <TD>
            Contains C implementations of TOOLS and TOOLS EXT words, the debugger, and debugger support words.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>vm.c</B>
          </TD>
          <TD>
            Virtual Machine methods
          </TD>
        </TR>
        <TR>
          <TD>
            <B>unix.c</B>
          </TD>
          <TD>
            Platform extensions words loaded in ficl.c by ficlCompilePlatform() - conditioned on FICL_WANT_PLATFORM
          </TD>
        </TR>
        <TR>
          <TD>
            <B>wasm_main.c</B>
          </TD>
          <TD>
            Entry points for the browser-based WebAssembly REPL. Provides ficlWasmInit, ficlWasmEval, and output-buffer functions for use from JavaScript.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>words.c</B>
          </TD>
          <TD>
            Exports ficlCompileCore(), the run-time dictionary builder, and contains most precompiled CORE and CORE-EXT words.
          </TD>
        </TR>
        <TR>
          <TD colspan="2">&nbsp;</TD>
        </TR>
        <TR>
          <TD>
            <B>doc/</B>
          </TD>
          <TD>
            Project documentation including this reference, the interactive WebAssembly demo, and articles on Ficl internals, OOP, the prefix parser, local variables, and the debugger.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>softwords/</B>
          </TD>
          <TD>
            Forth source files (.fr) for words compiled by Ficl at startup, including the object oriented extensions.
            A Python 3 script (softcore.py) converts the .fr files into softcore.c. See the makefile in this directory.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>test/</B>
          </TD>
          <TD>
            Forth test scripts that exercise the ANS CORE, CORE EXT, and other wordsets, as well as Ficl-specific features like the OOP extensions and prefix parser.
          </TD>
        </TR>
      </TABLE>
      <HR>
      <H2>
        <A name="internals"></A>Ficl Internals
      </H2>
      <!-- BEGIN FICL_GUTS -->
<h2>Major Data Structures</h2>
<p>
A running memory image of Ficl consists of one or more FICL_SYSTEMs,
each of which owns exactly one dictionary (FICL_DICT),
and one or more virtual machines (FICL_VM). Each VM owns two stacks
(FICL_STACK) - one for parameters (the parameter stack)
and one for return addresses (the return stack).
Ficl is a permissive, untyped language by nature,
so its fundamental unit of storage is a CELL: a chunk of memory
large enough to hold an address or a scalar type.
</p>
<svg viewBox="0 0 900 400" width="100%" height="auto" role="img" aria-labelledby="ficl-structures-title ficl-structures-desc" style="font-family: inherit; font-size: 14px;">
  <title id="ficl-structures-title">Ficl major data structures</title>
  <desc id="ficl-structures-desc">Diagram showing FICL_SYSTEM owning a dictionary and multiple virtual machines. Each VM owns parameter, return, and optional float stacks. The dictionary contains wordlists, FICL_WORD entries, and cell payloads.</desc>
  <defs>
    <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto" markerUnits="strokeWidth">
      <path d="M0,0 L10,5 L0,10 z" fill="#333"></path>
    </marker>
  </defs>
  <rect x="360" y="20" width="180" height="60" rx="10" fill="#f7f7f7" stroke="#333"></rect>
  <text x="450" y="55" text-anchor="middle" fill="#111">FICL_SYSTEM</text>

  <rect x="172" y="132" width="200" height="60" rx="10" fill="#f1f1f1" stroke="#333"></rect>
  <rect x="166" y="126" width="200" height="60" rx="10" fill="#f4f4f4" stroke="#333"></rect>
  <rect x="160" y="120" width="200" height="60" rx="10" fill="#f7f7f7" stroke="#333"></rect>
  <text x="260" y="155" text-anchor="middle" fill="#111">FICL_VM</text>

  <rect x="60" y="300" width="120" height="50" rx="8" fill="#ffffff" stroke="#333"></rect>
  <text x="120" y="330" text-anchor="middle" fill="#111">param stack</text>
  <rect x="200" y="300" width="120" height="50" rx="8" fill="#ffffff" stroke="#333"></rect>
  <text x="260" y="330" text-anchor="middle" fill="#111">return stack</text>
  <rect x="340" y="300" width="120" height="50" rx="8" fill="#ffffff" stroke="#333" stroke-dasharray="4 3"></rect>
  <text x="400" y="325" text-anchor="middle" fill="#111">float stack</text>
  <text x="400" y="345" text-anchor="middle" fill="#666">(optional)</text>

  <rect x="550" y="120" width="200" height="60" rx="10" fill="#f7f7f7" stroke="#333"></rect>
  <text x="650" y="155" text-anchor="middle" fill="#111">FICL_DICT</text>

  <rect x="562" y="232" width="200" height="50" rx="8" fill="#f1f1f1" stroke="#333"></rect>
  <rect x="556" y="226" width="200" height="50" rx="8" fill="#f4f4f4" stroke="#333"></rect>
  <rect x="550" y="220" width="200" height="50" rx="8" fill="#ffffff" stroke="#333"></rect>
  <text x="650" y="250" text-anchor="middle" fill="#111">FICL_WORDLIST</text>
  <rect x="562" y="302" width="200" height="50" rx="8" fill="#f1f1f1" stroke="#333"></rect>
  <rect x="556" y="296" width="200" height="50" rx="8" fill="#f4f4f4" stroke="#333"></rect>
  <rect x="550" y="290" width="200" height="50" rx="8" fill="#ffffff" stroke="#333"></rect>
  <text x="650" y="320" text-anchor="middle" fill="#111">FICL_WORD</text>

  <line x1="450" y1="80" x2="260" y2="120" stroke="#333" marker-end="url(#arrow)"></line>
  <line x1="450" y1="80" x2="650" y2="120" stroke="#333" marker-end="url(#arrow)"></line>
  <text x="280" y="110" text-anchor="middle" fill="#444">owns</text>
  <text x="570" y="110" text-anchor="middle" fill="#444">owns</text>

  <line x1="260" y1="180" x2="120" y2="300" stroke="#333" marker-end="url(#arrow)"></line>
  <line x1="260" y1="180" x2="260" y2="300" stroke="#333" marker-end="url(#arrow)"></line>
  <line x1="260" y1="180" x2="400" y2="300" stroke="#333" marker-end="url(#arrow)"></line>
  <text x="220" y="255" text-anchor="middle" fill="#444">owns</text>

  <line x1="650" y1="180" x2="650" y2="220" stroke="#333" marker-end="url(#arrow)"></line>
  <line x1="650" y1="270" x2="650" y2="290" stroke="#333" marker-end="url(#arrow)"></line>
  <text x="690" y="210" text-anchor="start" fill="#444">contains</text>
</svg>

<h3>FICL_SYSTEM</h3>
The system structure associates one or more virtual machines with a dictionary. All FICL_SYSTEMS
include a link pointer that is used to keep track of every allocated system so that memory
can be freed by ficlTermSystem. Each system contains a list of virtual machines associated with
it. Each system has at least one virtual machine. In a typical implementation, there is one virtual
machine per native OS thread, and there may be several VMs sharing a single FICL_SYSTEM, or one
FICL_SYSTEM per VM if the implementation needs to support multiple user sessions in a robust way.

A FICL_SYSTEM also includes a special dictionary for local variable support (if enabled
by FICL_WANT_LOCALS). Environment query constants are stored in a named wordlist within
the main dictionary. This wordlist can be accessed via the <code>environment-wordlist</code>
word and added to the search order for direct execution of environment constants.
<h3>FICL_DICT</h3>
A dictionary manages a fixed-size block of contiguous memory. It serves two roles: to keep track
of allocated memory, and to collect symbol tables called wordlists. Each dictionary contains at
least one wordlist. The dictionary organized memory (perhaps this is too kind) as an array of
CELLs that grows from low memory to high memory within fixed limits determined by the
FICL_DEFAULT_DICT parameter in sysdep.h.

A wordlist is the controlling structure of a Ficl symbol table. Each wordlist is a hash table
containing pointers to FICL_WORDs. Each FICL_WORD associates a pointer to code with one or more
CELLs of the dictionay. Each word usually has a name as well, but this is not required. It is
possible to create anonymous words using :NONAME.

Each word's code pointer determines that word's runtime behavior, and by implication the purpose
of its payload data. Some words interpret their payload as a list of Ficl words, and execute them.
This is how new behaviors of the language are defined. Other words view their payload field as
a location in which one or more CELLs can be stored (VARIABLEs, for example). At runtime, such
words push the address of their payload area onto the parameter stack.
<h3>FICL_VM</h3>
The virtual machine collects state related to execution of Ficl words. Each VM includes
registers used by the inner interpreter, some state variables (AKA user variables) such as
the current numeric base, and a jmpbuf.
A VM has a pointer to the FICL_SYSTEM of which it is a part. It also has a pointer to an incoming
text string that it is interpreting. There are VM methods that excute a word given its address
(xt), and ones that interpret a text string.
<h3>FICL_STACK</h3>
Each VM owns a parameter stack, a return stack, and if float support is enabled, a float parameter
stack. Parameters, return addresses, and floats are all CELL sized, and values may be
moved back and forth among stacks using various Ficl words for that purpose.&nbsp;
<h2>Inner Interpreter: Example Execution</h2>
<p>
This example shows how the inner interpreter executes a simple colon definition with control flow.
The word below computes a factorial using a counted loop and a running accumulator.
</p>
<pre>
: fact ( n -- n! )
  1 swap 1+ 1 ?DO
    I *
  LOOP
;
</pre>
<p>
Ficl stores colon definitions as a payload of execution tokens (XTs). In simplified form, the
payload for <code>fact</code> looks like this:
</p>
<pre>
XT (literal) 1
XT swap
XT (literal) 1
XT +
XT (?do) [exit address]
XT I
XT *
XT (loop) [branch address]
XT (;)
</pre>
<p>
When C code calls <code>ficlExecXT</code> with the <code>fact</code> word, it sets up a nested exception
frame, pushes the <code>exit-inner</code> sentinel on the IP stack, and then enters the inner loop.
The inner loop walks the XT list until <code>(;)</code> triggers <code>VM_INNEREXIT</code>.
</p>
<p>
If an XT in the payload refers to a colon definition, the inner loop executes
its code like any other word. The callee pushes the current instruction pointer, switches to its
own payload, and returns to the caller when <code>(;)</code> pops the saved IP.
</p>
<ul>
  <li>
    <B>Setup</B> Save the current <code>pState</code> and <code>runningWord</code>, install a new
    <code>jmp_buf</code>, and push <code>pExitInner</code> onto the IP stack.
  </li>
  <li>
    <B>Execute</B> <code>vmExecute</code> positions the IP at the word's payload, then
    <code>vmInnerLoop</code> executes XTs in order.
  </li>
  <li>
    <B>Looping</B> <code>(?do)</code> initializes the loop parameters, <code>I</code> fetches the loop
    index, and <code>(loop)</code> advances or exits the loop.
  </li>
  <li>
    <B>Exit</B> <code>(;)</code> throws <code>VM_INNEREXIT</code>, the inner loop unwinds, and
    <code>ficlExecXT</code> restores the previous <code>pState</code>.
  </li>
</ul>
      <!-- END FICL_GUTS -->
      <HR>
      <H2>
        <A name="extras"></A>Ficl extras
      </H2>
      <H3>
        <A name="exnumber"></A>Number syntax
      </H3>
      You can precede a number with "0x", as in C, and it will be interpreted as a hex value regardless of the value of <CODE>BASE</CODE>. Likewise, numbers prefixed with "0d" will be interpreted as
      decimal values. Example:
<PRE>
ok&gt; decimal 123 . cr
123
ok&gt; 0x123 . cr
291
ok&gt; 0x123 x. cr
123
</PRE>
      Note: ficl2.05 and later - this behavior is controlled by the <A href="#parsesteps">prefix parser</A> defined in <CODE>prefix.c</CODE>. You can add other prefixes by defining handlers for
      them in ficl or C.
      <H3>
        <A name="exsearch"></A> The <CODE>SEARCH</CODE> wordset and Ficl extensions
      </H3>
      <P>
        Ficl implements many of the search order words in terms of two primitives called <CODE><A href="#tosearch">&gt;SEARCH</A></CODE> and <CODE><A href="#searchfrom">SEARCH&gt;</A></CODE>. As
        their names suggest (assuming you're familiar with Forth), they push and pop the search order stack.
      </P>
      <P>
        The standard does not appear to specify any conditions under which the search order is reset to a sane state. Ficl resets the search order to its default state whenever <code>ABORT</code>
        happens. This includes stack underflows and overflows. <code>QUIT</code> does not affect the search order. The minimum search order (set by <code>ONLY</code>) is equivalent to
      </P>
<PRE>
FORTH-WORDLIST 1 SET-ORDER
</PRE>
      <P>
        There is a default maximum of 16 wordlists in the search order. This can be changed by redefining FICL_DEFAULT_VOCS (declared in sysdep.h).
      </P>
      <P>
        <B>Note</B>: Ficl resets the search order whenever it does <code>ABORT</code>. If you don't like this behavior, just comment out the dictResetSearchOrder() lines in ficlExec().
      </P>
      <DL>
        <DT>
          <A name="tosearch"></A><CODE>&gt;search ( wid -- )</CODE>
        </DT>
        <DD>
          Push <code>wid</code> onto the search order. Many of the other search order words are written in terms of the <code>SEARCH&gt;</code> and <code>&gt;SEARCH</code> primitives. This word can be defined in
          ANS Forth as follows
        </DD>
        <DD>
          <code>: &gt;search&nbsp;&nbsp; &gt;r get-order 1+ r&gt; swap set-order ;</code>
        </DD>
        <DT>
          <A name="searchfrom"></A><code>search&gt;&nbsp;&nbsp; ( -- wid )</code>
        </DT>
        <DD>
          Pop <code>wid</code> off the search order (can be coded in ANS Forth as&nbsp;<code>: search&gt;&nbsp; get-order nip 1- set-order ;</code> )
        </DD>
        <DT>
          <A name="ficlsetcurrent"></A><code>ficl-set-current&nbsp;&nbsp; ( wid -- old-wid )</code>
        </DT>
        <DD>
          Set wid as compile wordlist, leaving the previous compile wordlist on the stack
        </DD>
        <DT>
          <A name="ficlvocabulary"></A><code>ficl-vocabulary&nbsp;&nbsp; ( nBins "name" -- )</code>
        </DT>
        <DD>
          Creates a <code>ficl-wordlist</code> with the specified number of hash table bins, binds it to the name, and associates the semantics of <code>vocabulary</code> with it (replaces the top wid in the
          search order list with its own wid when executed)
        </DD>
        <DT>
          <A name="ficlwordlist"></A><code>ficl-wordlist&nbsp;&nbsp; ( nBins -- wid )</code>
        </DT>
        <DD>
          Creates a wordlist with the specified number of hash table bins, and leaves the address of the wordlist on the stack. A <code>ficl-wordlist</code> behaves exactly as a regular wordlist, but it
          may search faster depending on the number of bins chosen and the number of words it contains at search time. As implemented in ficl, a wordlist is single threaded by default. <code>
          ficl-named-wordlist</code> takes a name for the wordlist and creates a word that pushes the <code>wid</code>. This is by contrast to <code>VOCABULARY</code>, which also has a name, but replaces the
          top of the search order with its <code>wid</code>.
        </DD>
        <DT>
          <A name="ficlforgetwid"></A><code>forget-wid&nbsp;&nbsp; ( wid -- )</code>
        </DT>
        <DD>
          Iterates through the specified wordlist and unlinks all definitions whose xt addresses are greater than or equal to the value of <code>HERE</code>, the dictionary fill pointer.&nbsp;
        </DD>
        <DT>
          <A name="ficlhide"></A><code>hide&nbsp;&nbsp; ( -- current-wid-was )</code>
        </DT>
        <DD>
          Push the <code>hidden</code> wordlist onto the search order, and set it as the current compile wordlist (unsing <code>ficl-set-current</code>). Leaves the previous compile wordlist ID. I use this
          word to hide implementation factor words that have low reuse potential so that they don't clutter the default wordlist. To undo the effect of hide, execute&nbsp; <B><code>previous
          set-current</code></B>
        </DD>
        <DT>
          <A name="ficlhidden"></A><code>hidden&nbsp;&nbsp; ( -- wid )</code>
        </DT>
        <DD>
          Wordlist for storing implementation factors of ficl provided words. To see what's in there, try:&nbsp; <B><code>hide words previous set-current</code></B>
        </DD>
        <DT>
          <A name="wid-get-name"></A><code>wid-get-name&nbsp;&nbsp; ( wid -- c-addr u )</code>
        </DT>
        <DD>
          Ficl wordlists (2.05 and later) have a name property that can be assigned. This is used by <code>ORDER</code> to list the names of wordlists in the search order.&nbsp;
        </DD>
        <DT>
          <A name="wid-set-name"></A><code>wid-set-name&nbsp;&nbsp; ( c-addr wid -- )</code>
        </DT>
        <DD>
          Ficl wordlists (2.05 and later) have a name property that can be assigned. This is used by <code>ORDER</code> to list the names of wordlists in the search order. The name is assumed to be a \0
          terminated string (C style), which conveniently is how Ficl stores word names.&nbsp; See softwords/softcore.fr definition of <code>brand-wordlist</code>&nbsp;
        </DD>
        <DT>
          <A name="wid-set-super"></A><code>wid-set-super&nbsp;&nbsp; ( wid -- )</code>
        </DT>
        <DD>
          Ficl wordlists have a parent wordlist pointer that is not specified in standard Forth. Ficl initializes this pointer to NULL whenever it creates a wordlist, so it ordinarily has no effect.
          This word sets the parent pointer to the wordlist specified on the top of the stack. Ficl's implementation of <code>SEARCH-WORDLIST</code> will chain backward through the parent link of the
          wordlist when searching. This simplifies Ficl's object model in that the search order does not need to reflect an object's class hierarchy when searching for a method. It is possible to
          implement Ficl object syntax in strict ANS Forth, but method finders need to manipulate the search order explicitly.
        </DD>
      </DL>
      <H3>
        <A name="exuser"></A>User variables
      </H3>
      <DL>
        <DT>
          <code>user&nbsp;&nbsp; ( -- ) name</code>
        </DT>
        <DD>
          Create a user variable with the given name. User variables are virtual machine local. Each VM allocates a fixed amount of storage for them. You can change the maximum number of user
          variables allowed by defining FICL_USER_CELLS on your compiiler's command line. Default is 16 user cells. User variables behave like <code>VARIABLE</code>s in all other respects (you use @ and
          ! on them, for example). Example:
        </DD>
        <DD>
          <DL>
            <DD>
              <code>user current-class</code>
            </DD>
            <DD>
              <code>0 current-class !</code>
            </DD>
          </DL>
        </DD>
      </DL>
      <H3>
        <A name="exmisc"></A>Miscellaneous
      </H3>
      <DL>
        <DT>
          <code>-roll&nbsp;&nbsp; ( xu xu-1 ... x0 u -- x0 xu-1 ... x1 )&nbsp;</code>
        </DT>
        <DD>
          Rotate u+1 items on top of the stack after removing u. Rotation is in the opposite sense to <code>ROLL</code>
        </DD>
      </DL>
      <DL>
        <DT>
          <A name="minusrot"></A><code>-rot&nbsp;&nbsp; ( a b c -- c a b )</code>
        </DT>
        <DD>
          Rotate the top three stack entries, moving the top of stack to third place. I like to think of this as <code>1<SUP>1</SUP>/<SUB>2</SUB>swap</code> because it's good for tucking a single cell
          value behind a cell-pair (like an object).&nbsp;
        </DD>
      </DL>
      <DL>
        <DT>
          <code>.dict&nbsp;&nbsp; ( -- )</code>
        </DT>
        <DD>
          Print dictionary usage statistics
        </DD>
        <DT>
          <code>.env&nbsp;&nbsp; ( -- )</code>
        </DT>
        <DD>
          List all environment variables provided by the system
        </DD>
        <DT>
          <code>environment-wordlist&nbsp;&nbsp; ( -- wid )</code>
        </DT>
        <DD>
          Returns the wordlist identifier for the environment query wordlist. This wordlist
          can be added to the search order (e.g. <code>environment-wordlist >search</code>)
          to allow direct execution of environment constants.
        </DD>
        <DT>
          <code>.hash&nbsp;&nbsp; ( -- )</code>
        </DT>
        <DD>
          List hash table performance statistics of the wordlist that's first in the search order
        </DD>
        <DT>
          <code>.ver&nbsp;&nbsp; ( -- )</code>
        </DT>
        <DD>
          Display ficl version ID
        </DD>
        <DT>
          <A name="tobuf"></A><code>&gt;buf&nbsp;&nbsp; ( xt c-addr -- )</code>
        </DT>
        <DD>
          Redirect VM text output to the null-terminated buffer at <code>c-addr</code>, execute
          <code>xt</code> to completion, then restore the previous output handler and
          <code>pExtend</code> pointer. The buffer is cleared to an empty string before
          <code>xt</code> runs. The caller is responsible for ensuring the buffer is large enough
          to hold all text produced by <code>xt</code>. Example:
        </DD>
        <DD>
<PRE>
: greet ." Hello, World!" ;
create mybuf 256 allot
' greet mybuf &gt;buf   ( capture greet's output into mybuf )
mybuf type cr         ( prints: Hello, World! )
</PRE>
        </DD>
        <DT>
          <code>&gt;name&nbsp;&nbsp; ( xt -- c-addr u )</code>
        </DT>
        <DD>
          Convert a word's execution token into the address and length of its name
        </DD>
        <DT>
          <code>body&gt;&nbsp;&nbsp; ( a-addr -- xt )</code>
        </DT>
        <DD>
          Reverses the effect of <code>CORE</code> word <code>&gt;body</code> (converts a parameter field address to an execution token)
        </DD>
        <DT>
          <code>compile-only</code>
        </DT>
        <DD>
          Mark the most recently defined word as being executable only while in compile state. Many <code>immediate</code> words have this property.
        </DD>
        <DT>
          <code>empty&nbsp;&nbsp; ( -- )</code>&nbsp;
        </DT>
        <DD>
          Empty the parameter stack
        </DD>
        <DT>
          <code>endif</code>
        </DT>
        <DD>
          Synonym for <code>THEN</code>
        </DD>
        <DT>
          <A name="last-word"></A><code>last-word&nbsp;&nbsp; ( -- xt )</code>
        </DT>
        <DD>
          Pushes the xt address of the most recently defined word. This applies to colon definitions, constants, variables, and words that use <code>create</code>. You can print the name of the most
          recently defined word with&nbsp;
        </DD>
        <DD>
          <B><code>last-word &gt;name type</code>&nbsp;</B>
        </DD>
        <DT>
          <code>parse-word&nbsp;&nbsp; ( &lt;spaces&gt;name -- c-addr u )</code>
        </DT>
        <DD>
          Skip leading spaces and parse name delimited by a space. c-addr is the address within the input buffer and u is the length of the selected string. If the parse area is empty, the resulting
          string has a zero length. (From the Standard)
        </DD>
        <DT>
          <A name="qfetch"></A><code>q@&nbsp;&nbsp; ( addr -- x )</code>
        </DT>
        <DD>
          Fetch a 32 bit quantity from the specified address
        </DD>
        <DT>
          <A name="qbang"></A><code>q!&nbsp;&nbsp; ( x addr -- )</code>
        </DT>
        <DD>
          Store a 32 bit quantity to the specified address&nbsp;
        </DD>
        <DT>
          <code>w@&nbsp;&nbsp; ( addr -- x )</code>
        </DT>
        <DD>
          Fetch a 16 bit quantity from the specified address
        </DD>
        <DT>
          <code>w!&nbsp;&nbsp; ( x addr -- )</code>
        </DT>
        <DD>
          Store a 16 bit quantity to the specified address (the low 16 bits of the given value)
        </DD>
        <DT>
          <A name="xdot"></A><code>x.&nbsp;&nbsp; ( x -- )</code>
        </DT>
        <DD>
          Pop and display the value in hex format, regardless of the current value of <code>BASE</code>
        </DD>
      </DL>
      <H3>
        <A name="extestmain"></A>Extra words defined in testmain.c
      </H3>
      <DL>
        <DT>
          <code>break&nbsp;&nbsp; ( -- )</code>
        </DT>
        <DD>
          Does nothing - just a handy place to set a debugger breakpoint
        </DD>
        <DT>
          <code>cd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( "directory-name&lt;newline&gt;" -- )</code>
        </DT>
        <DD>
          Changes the working directory using the platform <code>chdir()</code> function (POSIX or Win32).
        </DD>
        <DT>
          <A name="clock"></A><code>clock&nbsp;&nbsp; ( -- now )</code>
        </DT>
        <DD>
          Returns the number of high-resolution timer ticks elapsed since process start (monotonic on POSIX/macOS, QPC on Windows).
        </DD>
        <DT>
          <A name="clockspersec"></A><code>clocks/sec&nbsp;&nbsp; ( -- clocks_per_sec )</code>
        </DT>
        <DD>
          Pushes the number of ticks in a second for <code>clock</code> (1,000,000,000 on POSIX/macOS; QPC frequency on Windows).
        </DD>
        <DT>
          <A name="ficlload"></A><code>load&nbsp;&nbsp;&nbsp; ( "filename&lt;newline&gt;" -- )</code>
        </DT>
        <DD>
          Opens the Forth source file specified and loads it one line at a time, like <code>INCLUDED (FILE)</code>
        </DD>
        <DT>
          <code>pwd&nbsp;&nbsp;&nbsp;&nbsp; ( -- )</code>
        </DT>
        <DD>
          Prints the current working directory as set by <code>cd</code>
        </DD>
        <DT>
          <code>system&nbsp; ( "command&lt;newline&gt;" -- )</code>
        </DT>
        <DD>
          Issues a command to the platform shell using the standard C <code>system()</code> call.
        </DD>
        <DT>
          <code>spewhash&nbsp;&nbsp; ( "filename&lt;newline&gt;" -- )</code>
        </DT>
        <DD>
          Dumps all threads of the current compilation wordlist to the specified text file. This was useful when I thought there might be some point in attempting to optimize the hash function. I no
          longer harbor those illusions.
        </DD>
        <DT>
          <code>test-error&nbsp;&nbsp; ( -- )</code>
        </DT>
        <DD>
          Increments the internal test-failure counter. Called by <code>ficltest.fr</code> whenever a
          test assertion fails. Not intended for interactive use.
        </DD>
        <DT>
          <code>#errors&nbsp;&nbsp; ( -- n )</code>
        </DT>
        <DD>
          Pushes the cumulative test-failure count (as incremented by <code>test-error</code>) onto
          the stack. Used by the test harness to report the total number of failures after a test run.
        </DD>
      </DL>
      <HR>
      <H2>
        <A name="locals"></A>Local Variables
      </H2>
<a NAME="locals-intro"></a>
Named locally scoped variables came late to Forth. Purists feel that experienced
Forth programmers ought to write supportable code using only anonymous
stack variables and good factoring, but complain that novices use
global variables too much. Local variables cost little in terms of code
size and execution speed, and are very convenient for OO programming, where
stack effects are more complex. I use them a lot (maybe I'm a weenie).&nbsp;
<br><a href="http://www.taygeta.com/forth/dpans13.htm">Please refer to
the Standard</a> for more information on local variables.
<h3>
<a NAME="jhlocal"></a>Johns-Hopkins local variables</h3>
ANS Forth does not specify a complete and satisfying local variable facility.
Instead it defines a foundation upon which to build one. Ficl comes with
an adaptation of the Johns-Hopkins local variable syntax developed by John
Hayes et al. This is my preferred form, and I've extended it to make <a href="#oop">OOP</a>
a bit simpler. Local variables can only be declared inside a definition,
and are only visible in that definition. Here's the syntax of a JH local
variable declaration:
<pre>
{ &lt;initialized-locals> | &lt;cleared-locals> -- &lt;ignored> }
</pre>
The declaration is designed to look like a stack comment, but it uses curly
braces instead of parens. The &lt;initialized-locals> names get their initial
values from the stack when the word executes. The &lt;cleared-locals> names
are (you guessed it) set to zero when the word executes, and any characters
between -- and } are treated as a comment. The | and -- sections are optional,
but they must appear in the order shown if they appear at all.&nbsp;
<br><b>Double cell locals </b>(AKA 2locals): ordinarily, each local represents
one cell. Local variable names prefixed with the characters "2:" in the declaration
are double-cell locals. The prefix is not part of the local variable's name, only
part of the declaration.
They behave the same as single cell locals in all
other respects. I use 2locals quite a bit in Ficl's OO classes, because
objects in Ficl require two cells on the stack.
<br><b>Float locals: </b>when Ficl is compiled with <code>FICL_WANT_FLOAT</code>,
local variable names prefixed with "f:" (or "F:") in the declaration are
float locals. Like the 2: prefix, the f: prefix is not part of the variable's
name. Float locals take their initial values from the float stack and push
to the float stack when referenced. A float local occupies one or two cells
in the locals frame depending on the size of <code>FICL_FLOAT</code> relative
to <code>CELL</code>.
<br>You can modify the
value of any local with <code><a href="http://www.taygeta.com/forth/dpans13.htm#13.6.1.2295">TO</a></code>.
<code>TO</code> determines whether it's operating on a <code>LOCAL</code>,
a <code>2LOCAL</code>, a float local, or a <code>VALUE</code>,
and does the right thing accordingly.
<br>Following are some examples to illustrate usage (they are not intended
to be good code otherwise). Try these out in the <A href="demo.html">demo</A> to get a feeling for
how they work. Also see <code>softwords/string.fr</code> for an example of use of locals
in OO code.
<pre>
: local-demo  { a b | c -- }
   ." a = " a . cr
   ." b = " b . cr
   ." c = " c . cr ;
1 2 local-demo  ( you should see 1 2 0 )

: my2dup  { 2:x }  x x ;  ( uses a 2local )
1 2 my2dup .s
.( you should see 1 2 1 2 on the stack ) cr empty

: my2swap  { 2:x 2:y -- y x }  y x ;  ( note use of 2locals )
1 2 3 4 my2swap .s
.( you should see 3 4 1 2 on the stack ) cr empty

: totally-lame-swap  { x y | temp -- y x }
   y to temp
   x to y
   temp to x
   x y ;

\ Using a float local (requires FICL_WANT_FLOAT)
: circle-area  { f:r -- f:area }
  r r f* 3.14159265e f* ;
</pre>
The last two definitions introduce the use of <code>TO</code> applied to local
variables.
<h3>Standard LOCALS and LOCALS EXT words</h3>
In addition to the Johns-Hopkins syntax, Ficl provides the standard
<code>LOCALS</code> and <code>LOCALS EXT</code> wordsets.
These produce the same compiled code as the JH syntax but only support
single-cell locals. The JH syntax adds support for <code>2LOCAL</code>s
and float locals.
<p>Ficl implements both local variable syntaxes
suggested in DPANS Appendix A.13. Examples:
<pre>
\ Using LOCALS| from LOCALS EXT
: -rot  ( a b c -- c a b )
  locals| c b a |
  c a b
;
</pre>

<pre>
\ Using LOCAL END-LOCAL
: -rot  ( a b c -- c a b )
   local c
   local b
   local a
   end-locals
   c a b
;
</pre>

<h3>Build Controls</h3>
<p>Local variable support is optional because it adds a small amount of overhead
to the outer interpreter. You can disable it by setting FICL_WANT_LOCALS
to 0 in sysdep.h or in your compiler flags.
</p>
<h3>Notes:</h3>
<ul>
  <li>
    Ficl's local variable syntax can make code quite a bit easier to read,
    so I encourage you to experiment with it.
  </li>
  <li>
    Locals or not, keep your words simple.
    If the stack twiddles are too complex, consider factoring the definition into
    smaller and simpler words.&nbsp;
  </li>
  <li>
    <a href="#oop">Ficl's OOP</a> code makes heavy use of local variables,
    so if you enable FICL_WANT_OOP, locals will also be enabled automatically.
  </li>
  <li>
    The default maximum number of local variables per definition is 16. It's controlled
    by FICL_MAX_LOCALS in sysdep.h.&nbsp;
  </li>
</ul>

      <HR>
      <H2>
        <A name="oop"></A>Object Oriented Programming
      </H2>

<table BORDER=0 CELLSPACING=3 COLS=1 WIDTH="675" >
<tr>
<td>
<h3>
Review of <a href="http://whatis.techtarget.com/definition/0,289893,sid9_gci212681,00.html">OO</a> ideas</h3>
Click <a href="oo_in_c.html#review">here</a> for a short review of OO ideas,
terms, and implementations in other languages, or <a href="http://www.soft-design.com/softinfo/objects.html">here</a>
for an introduction to the terms and principles of Object Oriented Programming
<h3>
Design goals of Ficl OO syntax</h3>
Ficl's object extensions provide the traditional OO benefits of associating
data with the code that manipulates it, and reuse through single inheritance.
Ficl also has some unusual capabilities that support interoperation with
systems written in C.&nbsp;
<ul>
<li>
Ficl objects are normally late bound for safety (late binding guarantees
that the appropriate method will always be invoked for a particular object).
Early binding is also available, provided you know the object's class at
compile-time.</li>

<li>
Ficl OOP supports single inheritance, aggregation, and arrays of objects.</li>

<li>
Classes have independent name spaces for their methods: methods are only
visible in the context of a class or object. Methods can be overridden
or added in subclasses; there is no fixed limit on the number of methods
of a class or subclass.</li>

<li>
Ficl OOP syntax is regular and unified over classes and objects. In ficl,
all classes are objects. Class methods include the ability to subclass
and instantiate.</li>

<li>
Ficl can adapt legacy data structures with object wrappers. You can model
a structure in a Ficl class, and create an instance that refers to an address
in memory that holds an instance of the structure. The <i>ref object</i>
can then manipulate the structure directly. This lets you wrap data structures
written and instantiated in C.</li>
</ul>

<h3>
Acknowledgements</h3>
Ficl is not the first Forth to include Object Oriented extensions. Ficl's
OO syntax owes a debt to the work of John Hayes and Dick Pountain, among
others. OO Ficl is different from other OO Forths in a few ways, though
(some things never change). First, unlike several implementations, the
syntax is documented (<a href="#ootutorial">below</a>) beyond the source
code. In Ficl's spirit of working with C code, the OO syntax provides means
to adapt existing data structures. I've tried to make Ficl's OO model simple
and safe by unifying classes and objects, providing late binding by default,
and separating namespaces so that methods and regular Forth words are not
easily confused.&nbsp;</td>
</tr>
</table>

<br>&nbsp;
<table BORDER=0 CELLSPACING=3 COLS=1 WIDTH="675" >
<tr>
<td>
<h3>
Ficl Object Model</h3>
All classes in Ficl are derived from the common base class <code><a href="#objectgloss">OBJECT,</a></code>
as shown in the <a href="#figure1">figure</a> below. All classes are instances
of <code><a href="#glossclass">METACLASS</a></code>. This means that classes
are objects, too. <code>METACLASS</code> implements the methods for messages
sent to classes. Class methods create instances and subclasses, and give
information about the class. Each class is represented by a data stucture
of three elements:&nbsp;
<ul>
<li>
The address (named <code>.CLASS</code> ) of a parent class, or zero if it's
a base class (only <code>OBJECT</code> and <code>METACLASS</code> have this property)</li>

<li>
The size (named <code>.SIZE</code> ) in address units of an instance of the
class</li>

<li>
A wordlist ID (named <code>.WID</code> ) for the methods of the class</li>
</ul>
In the figure below, <code>METACLASS</code> and <code>OBJECT</code> are real system-supplied
classes. The others are contrived to illustrate the relationships among
derived classes, instances, and the two system base classes. The dashed
line with an arrow at the end indicates that the object/class at the arrow
end is an instance of the class at the other end. The vertical line with
a triangle denotes inheritance.&nbsp;
<p>Note for the curious: <code>METACLASS</code> behaves like a class - it responds
to class messages and has the same properties as any other class. If you
want to twist your brain in knots, you can think of <code>METACLASS</code>
as an instance of itself.&nbsp;
<br>&nbsp;</td>
</tr>
</table>

<p><a NAME="figure1"></a><img src="ficl_oop.svg" alt="The Ficl Object Model diagram" style="max-width: 100%; height: auto;" vspace="10" width="652" height="442">
<br>&nbsp;
<table BORDER=0 CELLSPACING=3 COLS=1 WIDTH="675" >
<tr>
<td>
<h2>
<a NAME="ootutorial"></a>Ficl OO Syntax Tutorial</h2>

<h3>
Introduction</h3>
It's helpful to have some familiarity with Forth and the customary Forth
stack notation to understand this tutorial. To get started, take a look
at this <a href="http://www.taygeta.com/forth_intro/stackflo.html">web-based
Forth tutorial</a>. If you're comfortable with both OO and Forth, you can
<a href="#ootutorial-finally">jump
ahead</a>.
<p>A Ficl <a href="oo_in_c.html#object-def">object</a> associates a <a href="oo_in_c.html#class-def">class</a>
with an <a href="oo_in_c.html#instance-def">instance</a> (the storage for
one set of instance variables). This is done explicitly on Ficl's stack,
in that any Ficl object is represented by a cell pair:&nbsp;
<pre>
( instance-addr class-addr )
</pre>
The instance-addr is the address of the object's storage, and the class-addr
is the address of its class. Whenever a named Ficl object executes (eg.
when you type its name and press enter at the Ficl prompt), it leaves this
"signature". All methods by convention expect a class and instance on the
stack when they execute, too. In many other OO languages, including C++,
instances contain information about their classes (a <a href="http://www.mvps.org/vbvision/vtable.htm">vtable</a>
pointer, for example). By making this pairing explicit rather than implicit,
Ficl can be OO about chunks of data that don't realize that they are objects,
without sacrificing any robustness for native objects. That means that
you can use Ficl to write object wrappers for data structures created in
C or assembly language, as long as you can determine how they're laid out
in memory.&nbsp;
<br>Whenever&nbsp; you create an object in Ficl, you specify its class.
After that, the object always pushes its class and the address of its <a href="http://www.aware.com/Glossary/main.htm#P">payload
</a>(instance
variable space) when invoked by name.&nbsp;
<p>Classes are special kinds of objects that store the methods of their
instances, the size of an instance's payload, and a parent class pointer.
Classes themselves are instances of a special base class called <code>METACLASS</code>,
and all classes inherit from class <code>OBJECT</code>. This is confusing at
first, but it means that Ficl has a very simple syntax for constructing
and using objects. Class methods include subclassing (<code>SUB</code>), creating
initialized and uninitialized instances (<code>NEW</code> and <code>INSTANCE</code>),
and creating reference instances (<code>REF</code>), described later. Classes
also have methods for disassembling their methods (<code>SEE</code>), identifying
themselves (<code>ID</code>), and listing their pedigree (<code>PEDIGREE</code>).
All objects inherit (from <code>OBJECT</code>) methods for initializing instances
and arrays of instances, for performing array operations, and for getting
information about themselves.&nbsp;
<h3>
Methods and messages</h3>
Methods are the functions that objects execute in response to messages.
A message is a request to an object for a behavior that the object supports.
When it receives a message, the target object looks up a method that performs
the behavior for its class, and executes it. Any specific message may be
bound to different methods in different objects, according to class. This
separation of messages and methods allows objects to behave <a href="http://www.whatis.com/polymorp.htm">polymorphically</a>.
(In Ficl, methods are words defined in the context of a class, and messages
are the names of those words.) Ficl classes associate messages with methods
for their instances (a fancy way of saying that each class owns a wordlist).
Ficl provides a late-binding operator <b><code>--></code></b> that sends messages
to objects at run-time, and an early-binding operator <b><code>=></code></b>
that compiles a specific class's method. These operators are the only supported
way to invoke methods. Regular Forth words are not visible to the method-binding
operators,&nbsp; so there's no chance of confusing a message with a regular
word of the same name.&nbsp;</td>
</tr>
</table>

<table BORDER=0 CELLSPACING=3 COLS=1 WIDTH="675" >
<tr>
<td>
<h3>
<a NAME="ootutorial-finally"></a>Tutorial (finally!)</h3>
This is a tutorial. It works best if you follow along by pasting the examples
into the web demo. If you're unfamiliar with Forth, please see one of these <a href="#links">references</a>.
Ficl's OOP words are in vocabulary <code>OOP</code>. To put <code>OOP</code> in
the search order and make it the compilation wordlist, type:&nbsp;
<pre>
ONLY   ( reset to default search order )
ALSO OOP DEFINITIONS
</pre>
(<b>Note for beginners</b>: to see the effect of the commands above, type
<code>ORDER</code>
after each line. You can repeat the sequence above if you like.)
<p>To start, we'll work with the two base classes <code>OBJECT</code> and <code>METACLASS</code>.
Try this:&nbsp;
<pre>
metaclass --> methods
</pre>
The line above contains three words. The first is the name of a class,
so it pushes its signature on the stack. Since all classes are instances
of <code>METACLASS</code>, <code>METACLASS</code> behaves as if it is an instance
of itself (this is the only class with this property). It pushes the same
address twice: once for the class and once for the payload, since they
are the same. The next word finds a method in the context of a class and
executes it. In this case, the name of the method is <code>methods</code>.
Its job is to list all the methods that a class knows. What you get when
you execute this line is a list of all the class methods Ficl provides.&nbsp;
<pre>
object --> sub c-led
c-byte obj: .state
: init   { 2:this -- }
    this --> super --> init
    ." initializing an instance of "
    this --> class --> id type cr ;
: on   { led# 2:this -- }
    this --> .state --> get
    1 led# lshift or dup !led
    this --> .state --> set  ;
: off   { led# 2:this -- }
    this --> .state --> get
    1 led# lshift invert and dup !led
    this --> .state --> set  ;
end-class
</pre>
The first line causes base-class <code>OBJECT</code> to derive from itself a new class called
c-led. If you type <tt>order</tt> and <tt>words</tt> you will see that class building words are now visible. Now we'll add some instance variables and methods to the new class...&nbsp;
<br>
<p>
Note: I like to prefix the names of classes with "c-", and the
names of member variables with a dot, but this is just a convention. If
you don't like it, you can pick your own.
</p>
The second line adds an instance variable called <code>.state</code> to the
class. This particular instance variable is an object - it will be an instance
of c-byte, one of ficl's stock classes (the source for which can be found
in the distribution in softwords/classes.fr).&nbsp;
<br>Next we've defined a method called <code>init</code>. This line also declares
a <a href="#locals">local variable</a> called <b><code>this</code></b>
(the 2 in front tells Ficl that this is a double-cell local). All methods
by convention expect the address of the class and instance on top of the
stack when called.&nbsp; The next three lines define <code>init</code>'s behavior.
It first calls its superclass's version of <code>init</code> (which in this
case is <code>object => init</code> - this default implementation clears all
instance variables). The rest displays some text and causes the instance
to print its class name (<code>this --> class --> id</code>).
<br>The <b><code>init</code></b> method is special for Ficl objects: whenever
you create an initialized instance using <b><code>new</code></b> or <b><code>new-array</code></b>,
Ficl calls the class's <code>init</code> method for you on that instance. The
default <code>init</code> method supplied by <code>object</code> clears the instance,
so we didn't really need to override it in this case (see the source code
in ficl/softwords/oo.fr).&nbsp;
<br>The <code>ON</code> and <code>OFF</code> methods defined above hide the details
of turning LEDs on and off. The interface to the demo's simulated hardware
is handled by <code>!led</code>. The class keeps the LED state in a shadow
variable (<code>.STATE</code>) so that <code>ON</code> and <code>OFF</code> can work
in terms of LED number rather than a bitmask.
<p>Now make an instance of the new class:&nbsp;
<pre>
c-led --> new led
</pre>
And try a few things...&nbsp;
<pre>
led --> methods
led --> pedigree
1 led --> on
1 led --> off
</pre>
Or you could type this with the same effect:&nbsp;
<pre>
led  2dup  --> methods  --> pedigree
</pre>
Notice (from the output of <code>methods</code>) that we've overridden the
init method supplied by object, and added two more methods for the member
variables. If you type <code>WORDS</code>, you'll see that these methods are
not visible outside the context of the class that contains them. The method
finder <b><code>--></code></b> uses the class to look up methods. You can use
this word in a definition, as we did in <code>init</code>, and it performs
late binding, meaning that the mapping from message (method name) to method
(the code) is deferred until run-time. To see this, you can decompile the
init method like this:&nbsp;
<pre>
c-led --> see init
</pre>
or
<pre>
led --> class --> see init
</pre>

<h3>
Early binding</h3>
Ficl also provides early binding if you ask for it. Early binding is not
as safe as late binding, but it produces code that is more compact and
efficient because it compiles method addresses rather then their names.
In the preferred uses of early binding, the class is assumed to be the
one you're defining. This kind of early binding can only be used inside
a class definition. Early bound methods still expect to find a class and
instance cell-pair on top of the stack when they run.
<br>Here's an example that illustrates a potential problem:
<pre>
object --> sub c1
: m1   { 2:this -- }  ." c1's m1" cr ;
: m2   { 2:this -- }  ." Running  " this  my=> m1 ; ( early )
: m3   { 2:this -- }  ." Running  " this --> m1     ( late )
end-class
c1     --> sub c2
: m1   { 2:this -- }  ." c2's m1" cr ;
end-class
c2 --> new i2
i2 --> m1   ( runs the m1 defined in c2 )
i2 --> m2   ( is this what you wanted? )
i2 --> m3   { runs the overridden m1)
</pre>
Even though we overrode method m1 in class c2, the definition of m2 with
early binding forced the use of m1 as defined in c1. If that's what you
want, great, but more often you'll want the flexibility of overriding parent
class behaviors appropriately.&nbsp;
<ol>
<li>
<code>my=></code> binds early to a method in the class being defined,
as in the example above.
</li>
<li>
<code>my=[ ]</code> binds a sequence of methods in the current class.
Useful when the class has object members. Lines like <code>this --> state
--> set</code> in the definition of c-led above can be replaced with
<code>this my=[ state set ]</code> to get early binding.
</li>
<li>
<code>=></code> (dangerous) pops a class off the stack and compiles
the method in that class. Since you have to specify the class explicitly,
there is a real danger that this will be out of sync with the class you
really wanted. I recommend the <code>my=</code> operations.
</li>
</ol>
Early binding using <code>=></code> is dangerous because it partially
defeats the data-to-code matching mechanism object oriented languages were
created to provide, but it does increase run-time speed by binding the
method at compile time. In many cases, such as the <code>init</code> method,
you can be reasonably certain of the class of thing you're working on.
This is also true when invoking class methods, since all classes are instances
of <code>metaclass</code>. Here's an example from the definition of <code>metaclass</code>
in oo.fr:
<pre>
: new   \ ( class metaclass "name" -- )
    metaclass => instance --> init ;
</pre>
Try this...
<pre>
metaclass --> see new
</pre>
Decompiling the method with <code>SEE</code> shows the difference between the
two strategies. The early bound method is compiled inline, while the late-binding
operator compiles the method name and code to find and execute it in the
context of whatever class is supplied on the stack at run-time.
<br>Notice that the primitive early-binding operator <code>=></code> requires
a class at compile time. For this reason, classes are <code>IMMEDIATE</code>,
meaning that they push their signature at compile time or run time. I'd
recommend that you avoid early binding until you're very comfortable with
Forth, object-oriented programming, and Ficl's OOP syntax.
<br>
<h3>
More About Instance Variables</h3>
<i>Untyped</i> instance variable methods (created by <code>cell: cells: char:</code>
and <code>chars:</code>) just push the address of the corresponding instance
variable when invoked on an instance of the class. It's up to you to remember
the size of the instance variable and manipulate it with the usual Forth
words for fetching and storing.&nbsp;
<p>As advertised earlier, Ficl provides ways to objectify existing data
structures without changing them. Instead, you can create a Ficl class
that models the structure, and instantiate a <b>ref </b>from this class,
supplying the address of the structure. After that, the <i>ref instance</i>
behaves as a Ficl object, but its instance variables take on the values
in the existing structure. Example (from ficlclass.fr):&nbsp;
<pre>
object subclass c-wordlist
  c-wordlist  ref: .parent
  c-ptr       obj: .name
  c-cell      obj: .size
  c-word      ref: .hash

: ?
  2drop ." ficl wordlist" cr ;
: push  drop >search ;
: pop   2drop previous ;
: set-current drop set-current ;
: words  --> push  words previous ;
end-class
</pre>
In this case, <code>c-wordlist</code> describes Ficl's wordlist structure;
named-wid creates a wordlist and binds it to a ref instance of <code>c-wordlist</code>.
The fancy footwork with <code>POSTPONE</code> and early binding is required
because classes are immediate. An equivalent way to define named-wid with
late binding is:&nbsp;
<pre>
: named-wid   ( "name" -- )
   wordlist  postpone c-wordlist --> ref ;
</pre>
To do the same thing at run-time (and call it my-wordlist):&nbsp;
<pre>
wordlist  c-wordlist --> ref my-wordlist
</pre>
Now you can deal with the wordlist through the ref instance:&nbsp;
<pre>
my-wordlist --> push
my-wordlist --> set-current
order</pre>
Ficl can also model linked lists and other structures that contain pointers
to structures of the same or different types. The class constructor word
<b><code><a href="#exampleref:">ref:</a></code></b>
makes an aggregate reference to a particular class. See the <a href="#glossinstance">instance
variable glossary</a> for an <a href="#exampleref:">example</a>.&nbsp;
<p>Ficl can make arrays of instances, and aggregate arrays into class descripions.
The <a href="#glossclass">class methods</a> <b><code>array</code></b> and <b><code>new-array</code></b>
create uninitialized and initialized arrays, respectively, of a class.
In order to initialize an array, the class must define (or inherit) a reasonable
<b><code>init</code></b>
method. <b><code>New-array</code></b> invokes it on each member of the array
in sequence from lowest to highest. Array instances and array members use
the object methods <b><code>index</code></b>, <b><code>next</code></b>, and <b><code>prev</code></b>
to navigate. Aggregate a member array of objects using <b><code><a href="#arraycolon">array:</a></code></b>.
The objects are not automatically initialized in this case - your class
initializer has to call <b><code>array-init</code></b> explicitly if you want
this behavior.&nbsp;
<p>For further examples of OOP in Ficl, please see the source file ficl/softwords/ficlclass.fr.
This file wraps several Ficl internal data structures in objects and gives
use examples.&nbsp;</td>
</tr>

<tr>
<td>
<h3>
<a NAME="cstring"></a>Ficl String classes</h3>
c-string (ficl 2.04 and later) is a reasonably useful dynamic string class.
Source code for the class is located in ficl/softwords/string.fr. Features:
dynamic creation and resizing; deletion, char cout, concatenation, output,
comparison; creation from quoted string constant (s").
<p>Examples of use:
<pre>
c-string --> new homer
s" In this house, " homer --> set
s" we obey the laws of thermodynamics!" homer --> cat
homer --> type
</pre>
</td>
</tr>
</table>

<table BORDER=0 CELLSPACING=3 COLS=1 WIDTH="675" >
<tr>
<td>
<h3>
<a NAME="oopgloss"></a>OOP Glossary</h3>
Note: with the exception of the binding operators (the first two definitions
here), all of the words in this section are internal factors that you don't
need to worry about. These words provide method binding for all classes
and instances. Also described are supporting words and execution factors.
All are defined in softwords/oo.fr.&nbsp;
<dl>
<dt>
<b><code>-->   ( instance class "method-name" -- xn )</code></b></dt>

<dd>
Late binding: looks up and executes the given method in the context of
the class on top of the stack.&nbsp;</dd>

<dt>
<b><code>c->   ( instance class "method-name" -- xn exc )</code></b></dt>

<dd>
Late binding with <code>CATCH</code>: looks up and <code>CATCH</code>es the given
method in the context of the class on top of the stack, pushes zero or
exception code upon return.</dd>

<dt>
<b><code>my=> comp: ( "method-name" -- )  exec: ( inst class -- xn )</code></b></dt>

<dd>
Early binding: compiles code to execute the method of the class being defined.
Only visible and valid in the scope of a <code>--> sub</code> .. <code>end-class</code>
class definition.</dd>

<dt>
<b><code>my=[ comp: ( "obj1 obj2 .. method ]" -- ) exec:( inst class -- xn
)</code></b></dt>

<dd>
Early binding: compiles code to execute a chain of methods of the class
being defined. Only visible and valid in the scope of a <code>--> sub</code>
.. <code>end-class</code> class definition.</dd>

<dt>
<b><code>=>   comp: ( class meta "method-name" -- )  exec:
( inst class -- xn )</code></b></dt>

<dd>
Early binding: compiles code to execute the method of the class specified
at compile time.</dd>

<dt>
<b><code>do-do-instance</code></b></dt>

<dd>
When executed, causes the instance to push its ( instance class ) stack
signature. Implementation factor of <b><code>metaclass --> sub</code></b>.
Compiles <b><code>.do-instance</code></b> in the context of a class; <code>.do-instance</code>
implements the <code>does></code> part of a named instance.&nbsp;</dd>

<dt>
<b><code>exec-method   ( instance class c-addr u -- xn )</code></b></dt>

<dd>
Given the address and length of a message (method name) on the stack, finds
the method in the context of the specified class and invokes it. Upon entry
to the method, the instance and class are on top of the stack, as usual.
If unable to find the method, prints an error message and aborts.</dd>

<dt>
<b><code>find-method-xt   ( class "method-name" -- class xt )</code></b></dt>

<dd>
Attempts to map the message to a method in the specified class. If successful,
leaves the class and the execution token of the method on the stack. Otherwise
prints an error message and aborts.</dd>

<dt>
<b><code>lookup-method   ( class c-addr u -- class xt )</code></b></dt>

<dd>
Given the address and length of a message (method name) on the stack, finds
the method in the context of the specified class. If unable to find the
method, prints an error message and aborts.</dd>

<dt>
<b><code>parse-method   comp: ( "method-name" -- )  exec:
( -- c-addr u )</code></b></dt>

<dd>
Parse "name" from the input stream and compile code to push its length
and address when the enclosing definition runs.</dd>
</dl>
</td>
</tr>
</table>

<table BORDER=0 CELLSPACING=3 COLS=1 WIDTH="675" >
<tr>
<td>
<h3>
<a NAME="glossinstance"></a>Instance Variable Glossary</h3>
<b>Note</b>: these words are only visible when creating a subclass! To
create a subclass, use the <code>sub</code> method on <code>object</code> or any
class derived from it (<i>not</i> <code>metaclass</code>). Source code for
Ficl OOP is in ficl/softwords/oo.fr.&nbsp;
<br>Instance variable words do two things: they create methods that do
an action appropriate for the type of instance variable they represent,
and they reserve space in the class template for the instance variable.
We'll use the term <i>instance variable</i> to refer both to the method
that gives access to a particular field of an object, and to the field
itself. Rather than give esentially the same example over and over, here's
one example that shows several of the instance variable construction words
in use:
<pre>
object subclass c-example
  cell:         .cell0
  c-4byte  obj: .nCells
 4 c-4byte array: .quad
  char:         .length
79 chars:       .name
end-class
</pre>
This class only defines instance variables, and it inherits some methods
from <code>object</code>. Each untyped instance variable (.cell0, .length,
.name) pushes its address when executed. Each object instance variable
pushes the address and class of the aggregate object. Similar to C, an
array instance variable leaves its base address (and its class) when executed.
The word <code>subclass</code> is shorthand for "<code>--> sub</code>"&nbsp;
<dl>
<dt>
<b><code>cell:
( offset "name" -- offset' )</code></b></dt>

<dt>
<b><code>Execution:  ( -- cell-addr
)</code></b></dt>

<dd>
Create an untyped instance variable one cell wide. The instance variable
leaves its payload's address when executed.&nbsp;</dd>

<dt>
<b><code>cells:       ( offset nCells "name"
-- offset' )</code></b></dt>

<dt>
<b><code>
Execution:  ( -- cell-addr )</code></b></dt>

<dd>
Create an untyped instance variable n cells wide.</dd>

<dt>
<b><code>char:        ( offset "name"
-- offset' )</code></b></dt>

<dt>
<b><code>
Execution:  ( -- char-addr )</code></b></dt>

<dd>
Create an untyped member variable one char wide</dd>

<dt>
<b><code>chars:       ( offset nChars "name"
-- offset' )</code></b></dt>

<dt>
<b><code>
Execution:  ( -- char-addr )</code></b></dt>

<dd>
Create an untyped member variable n chars wide.</dd>

<dt>
<b><code>obj:         ( offset class
meta "name" -- offset' )</code></b></dt>

<dt>
<b><code>
Execution:  ( -- instance class )</code></b></dt>

<dd>
Aggregate an uninitialized instance of <b>class</b> as a member variable
of the class under construction.</dd>

<dt>
<a NAME="arraycolon"></a><b><code>array:
( offset n class meta "name" -- offset' )</code></b></dt>

<dt>
<b><code>
Execution:  ( -- instance class )</code></b></dt>

<dd>
Aggregate an uninitialized array of instances of the class specified as
a member variable of the class under construction.</dd>

<dt>
<a NAME="exampleref:"></a><b><code>ref:
( offset class meta "name" -- offset' )</code></b></dt>

<dt>
<b><code>
Execution:  ( -- ref-instance ref-class )</code></b></dt>

<dd>
Aggregate a reference to a class instance. There is no way to set the value
of an aggregated ref - it's meant as a way to manipulate existing data
structures with a Ficl OO model. For example, if your system contains a
linked list of 4 byte quantities, you can make a class that represents
a list element like this:&nbsp;</dd>

<pre>
object subclass c-4list
c-4list ref: .link
c-4byte obj: .payload
end-class;
address-of-existing-list c-4list --> ref mylist
</pre>

<dd>
The last line binds the existing structure to an instance of the class
we just created. The link method pushes the link value and the class c_4list,
so that the link looks like an object to Ficl and like a struct to C (it
doesn't carry any extra baggage for the object model - the Ficl methods
alone take care of storing the class information).&nbsp;</dd>

<dd>
Note: Since a ref: aggregate can only support one class, it's good for
modeling static structures, but not appropriate for polymorphism. If you
want polymorphism, aggregate a c_ref (see classes.fr for source) into your
class - it has methods to set and get an object.</dd>

<dd>
By the way, it is also possible to construct a pair of classes that contain
aggregate pointers to each other. Here's an example:</dd>

<pre>
object subclass akbar
suspend-class    \ put akbar on hold while we define jeff
object subclass jeff
   akbar ref: .significant-other
   ( your additional methods here )
end-class        \ done with jeff
akbar --> resume-class  \ resume defining akbar
   jeff ref: .significant-other
   ( your additional methods here )
end-class        \ done with akbar
</pre>
</dl>
</td>
</tr>
</table>

<table BORDER=0 CELLSPACING=3 COLS=1 WIDTH="675" >
<tr>
<td>
<h3>
<a NAME="glossclass"></a>Class Methods Glossary</h3>
These words are methods of <code>metaclass</code>. They define the manipulations
that can be performed on classes. Methods include various kinds of instantiation,
programming tools, and access to member variables of classes. Source is
in softwords/oo.fr.&nbsp;
<dl>
<dt>
<b><code>instance     ( class metaclass "name" -- instance
class )</code></b>&nbsp;</dt>

<dd>
Create an uninitialized instance of the class, giving it the name specified.
The method leaves the instance 's signature on the stack (handy if you
want to initialize). Example:</dd>

<dd>
<code>c_ref --> instance uninit-ref  2drop</code></dd>

<dt>
<b><code>new          ( class
metaclass "name" -- )</code></b>&nbsp;</dt>

<dd>
Create an initialized instance of class, giving it the name specified.
This method calls init to perform initialization.&nbsp;</dd>

<dt>
<b><code>array        ( nObj class metaclass
"name" -- nObjs instance class )</code></b>&nbsp;</dt>

<dd>
Create an array of nObj instances of the specified class. Instances are
not initialized. Example:</dd>

<dd>
<code>10 c_4byte --> array  40-raw-bytes  2drop drop</code></dd>

<dt>
<b><code>new-array    ( nObj class metaclass "name" -- )</code></b>&nbsp;</dt>

<dd>
Creates an initialized array of nObj instances of the class. Same syntax
as <code>array</code></dd>

<dt>
<a NAME="alloc"></a><b><code>alloc   ( class metaclass -- instance
class )</code></b></dt>

<dd>
Creates an anonymous instance of <b>class</b> from the heap (using a call
to ficlMalloc() to get the memory). Leaves the payload and class addresses
on the stack. Usage example:</dd>

<dd>
<code>c-ref --> alloc  2constant instance-of-ref</code></dd>

<dd>
Creates a double-cell constant that pushes the payload and class address
of a heap instance of c-ref.</dd>

<dt>
<a NAME="allocarray"></a><b><code>alloc-array   ( nObj class metaclass
-- instance class )</code></b></dt>

<dd>
Same as new-array, but creates anonymous instances from the heap using
a call to ficlMalloc(). Each instance is initialized using the class's
<code>init</code>
method</dd>

<dt>
<a NAME="allot"></a><b><code>allot   ( class metaclass -- instance
class )</code></b></dt>

<dd>
Creates an anonymous instance of <b>class</b> from the dictionary. Leaves
the payload and class addresses on the stack. Usage example:</dd>

<dd>
<code>c-ref --> allot  2constant instance-of-ref</code></dd>

<dd>
Creates a double-cell constant that pushes the payload and class address
of a heap instance of c-ref.</dd>

<dt>
<a NAME="allotarray"></a><b><code>allot-array   ( nObj class metaclass
-- instance class )</code></b></dt>

<dd>
Same as new-array, but creates anonymous instances from the dictionary.
Each instance is initialized using the class's
<code>init</code> method</dd>

<dt>
<b><code>ref          ( instance-addr
class metaclass "name" -- )</code></b>&nbsp;</dt>

<dd>
Make a ref instance of the class that points to the supplied instance address.
No new instance space is allotted. Instead, the instance refers to the
address supplied on the stack forever afterward. For wrapping existing
structures.</dd>
</dl>

<dl>
<dt>
<b><code>sub          ( class
metaclass -- old-wid addr[size] size )</code></b></dt>

<dd>
Derive a subclass. You can add or override methods, and add instance variables.
Alias: <code>subclass</code>. Examples:</dd>

<dl>
<dd>
<code>c_4byte --> sub c_special4byte</code></dd>

<dd>
<code>( your new methods and instance variables here )</code></dd>

<dd>
<code>end-class</code></dd>

<dd>
or</dd>

<dd>
<code>c_4byte subclass c_special4byte</code></dd>

<dd>
<code>( your new methods and instance variables here )</code></dd>

<dd>
<code>end-class</code></dd>
</dl>

<dt>
<b><code>.size        ( class metaclass
-- instance-size )</code></b>&nbsp;</dt>

<dd>
Returns address of the class's instance size field, in address units. This
is a metaclass member variable.</dd>

<dt>
<b><code>.super       ( class metaclass --
superclass )</code></b>&nbsp;</dt>

<dd>
Returns address of the class's superclass field. This is a metaclass member
variable.</dd>

<dt>
<b><code>.wid         ( class metaclass
-- wid )</code></b>&nbsp;</dt>

<dd>
Returns the address of the class's wordlist ID field. This is a metaclass
member variable.</dd>

<dt>
<b><code>get-size</code></b></dt>

<dd>
Returns the size of an instance of the class in address units. Imeplemented
as</dd>

<dd>
<code>: get-size   metaclass => .size @ ;</code></dd>

<dt>
<b><code>get-wid</code></b></dt>

<dd>
Returns the wordlist ID of the class. Implemented as&nbsp;</dd>

<dd>
<code>: get-wid   metaclass => .wid @ ;</code></dd>

<dt>
<b><code>get-super</code></b></dt>

<dd>
Returns the class's superclass. Implemented as</dd>

<dd>
<code>: get-super   metaclass => .super @ ;</code></dd>

<dt>
<b><code>id           (
class metaclass -- c-addr u )</code></b>&nbsp;</dt>

<dd>
Returns the address and length of a string that names the class.</dd>

<dt>
<b><code>methods      ( class metaclass -- )</code></b>&nbsp;</dt>

<dd>
Lists methods of the class and all its superclasses</dd>

<dt>
<b><code>offset-of    ( class metaclass "name" -- offset )</code></b></dt>

<dd>
Pushes the offset from the instance base address of the named member variable.
If the name is not that of an instance variable method, you get garbage.
There is presently no way to detect this error. Example:</dd>

<dl>
<dd>
<code>metaclass --> offset-of .wid</code></dd>
</dl>

<dt>
<b><code>pedigree     ( class metaclass -- )</code></b>&nbsp;</dt>

<dd>
Lists the pedigree of the class (inheritance trail)</dd>

<dt>
<b><code>see          ( class
metaclass "name" -- )</code></b>&nbsp;</dt>

<dd>
Decompiles the specified method - obect version of <code>SEE</code>, from the
<code>TOOLS</code>
wordset.</dd>
</dl>
</td>
</tr>
</table>

<table BORDER=0 CELLSPACING=3 COLS=1 WIDTH="675" >
<tr>
<td>
<h3>
<a NAME="objectgloss"></a><code>object</code> base-class Methods Glossary</h3>
These are methods that are defined for all instances by the base class
<code>object</code>.
The methods include default initialization, array manipulations, aliases
of class methods, upcasting, and programming tools.&nbsp;
<dl>
<dt>
<b><code>init         ( instance
class -- )</code>&nbsp;</b></dt>

<dd>
Default initializer called automatically for all instances created with
<code>new</code>
or <code>new-array</code>. Zero-fills the instance. You do not normally need
to invoke <code>init</code> explicitly.</dd>

<dt>
<b><code>array-init   ( nObj instance class -- )</code></b>&nbsp;</dt>

<dd>
Applies <code>init</code> to an array of objects created by <code>new-array</code>.
Note that <code>array:</code> does not cause aggregate arrays to be initialized
automatically. You do not normally need to invoke <code>array-init</code> explicitly.</dd>

<dt>
<a NAME="oofree"></a><b><code>free   ( instance class -- )</code></b></dt>

<dd>
Releases memory used by an instance previously created with <code>alloc</code>
or <code>alloc-array</code>. Note - this method is not presently protected
against accidentally deleting something from the dictionary. If you do
this, Bad Things are likely to happen. Be careful for the moment to apply
free only to instances created with <code>alloc</code> or <code>alloc-array</code>.</dd>

<dt>
<b><code>class        ( instance class -- class metaclass )</code></b>&nbsp;</dt>
<dd>
Convert an object signature into that of its class. Useful for calling
class methods that have no object aliases.</dd>

<dt>
<b><code>super        ( instance class
-- instance parent-class )</code></b>&nbsp;</dt>

<dd>
Upcast an object to its parent class. The parent class of <code>object</code>
is zero. Useful for invoking an overridden parent class method.</dd>

<dt>
<b><code>pedigree     ( instance class -- )</code></b>&nbsp;</dt>
<dd>
Display an object's pedigree - its chain of inheritance. This is an alias
for the corresponding class method.</dd>

<dt>
<b><code>size         ( instance
class -- sizeof(instance) )</code></b>&nbsp;</dt>
<dd>
Returns the size, in address units, of one instance. Does not know about
arrays! This is an alias for the class method <code>get-size</code></dd>

<dt>
<b><code>methods      ( instance class -- )</code></b>&nbsp;</dt>
<dd>
Class method alias. Displays the list of methods of the class and all superclasses
of the instance.</dd>

<dt>
<b><code>index        ( n instance class
-- instance[n] class )</code></b>&nbsp;</dt>
<dd>
Convert array-of-objects base signature into signature for array element
n. No check for bounds overflow. Index is zero-based, like C, so&nbsp;</dd>

<dl>
<dd>
<code>0 my-obj --> index</code>&nbsp;</dd>
</dl>

<dd>
is equivalent to&nbsp;</dd>

<dl>
<dd>
<code>my-obj</code></dd>
</dl>

<dd>
Check out the <a href="#minusrot">description of <code>-ROT</code></a> for
help in dealing with indices on the stack.</dd>

<dt>
<b><code>next         ( instance[n]
class -- instance[n+1] class )</code></b>&nbsp;</dt>

<dd>
Convert an array-object signature&nbsp; into the signature of the next
object in the array. No check for bounds overflow.</dd>

<dt>
<b><code>prev         ( instance[n]
class -- instance[n-1] class )</code></b>&nbsp;</dt>

<br>Convert an object signature into the signature of the previous object
in the array. No check for bounds underflow.</dl>
</td>
</tr>
</table>

<table BORDER=0 CELLSPACING=3 COLS=1 WIDTH="675" >
<tr>
<td>
<h3>
<a NAME="stockclasses"></a>Supplied Classes (See classes.fr)</h3>

<dl>
<dt>
<b><code>metaclass </code></b></dt>

<dd>
Describes all classes of Ficl. Contains class methods. Should never be
directly instantiated or subclassed. Defined in oo.fr. Methods described
above.</dd>

<dt>
<b><code>object</code>&nbsp;</b></dt>

<dd>
Mother of all Ficl objects. Defines default initialization and array indexing
methods. Defined in oo.fr. Methods described above.</dd>

<dt>
<b><code>c-ref</code>&nbsp;</b></dt>

<dd>
Holds the signature of another object. Aggregate one of these into a data
structure or container class to get polymorphic behavior. Methods &amp;
members:&nbsp;</dd>

<dd>
<code>get   ( inst class -- ref-inst ref-class )</code></dd>

<dd>
<code>set   ( ref-inst ref-class inst class -- )</code></dd>

<dd>
<code>.instance   ( inst class -- a-addr ) </code>cell member that
holds the instance</dd>

<dd>
<code>.class   ( inst class -- a-addr ) </code>cell member that holds
the class</dd>

<dt>
<b><code>c-byte </code></b></dt>

<dd>
Primitive class derived from <code>object</code>, with a 1-byte payload. Set
and get methods perform correct width fetch and store. Methods &amp; members:</dd>

<dd>
<code>get   ( inst class -- c )</code></dd>

<dd>
<code>set   ( c inst class -- )</code></dd>

<dd>
<code>.payload   ( inst class -- addr ) </code>member holds instance's
value</dd>

<dt>
<b><code>c-2byte</code></b>&nbsp;</dt>

<dd>
Primitive class derived from <code>object</code>, with a 2-byte payload. Set
and get methods perform correct width fetch and store. Methods &amp; members:</dd>

<dd>
<code>get   ( inst class -- 2byte )</code></dd>

<dd>
<code>set   ( 2byte inst class -- )</code></dd>

<dd>
<code>.payload   ( inst class -- addr ) </code>member holds instance's
value</dd>

<dt>
<b><code>c-4byte</code></b>&nbsp;</dt>

<dd>
Primitive class derived from <code>object</code>, with a 4-byte payload. Set
and get methods perform correct width fetch and store. Methods &amp; members:</dd>

<dd>
<code>get   ( inst class -- x )</code></dd>

<dd>
<code>set   ( x inst class -- )</code></dd>

<dd>
<code>.payload   ( inst class -- addr ) </code>member holds instance's
value</dd>

<dt>
<b><code>c-cell</code></b>&nbsp;</dt>

<dd>
Primitive class derived from <code>object</code>, with a cell payload (equivalent
to c-4byte in 32 bit implementations, 64 bits wide on Alpha). Set and get
methods perform correct width fetch and store. Methods &amp; members:</dd>

<dd>
<code>get   ( inst class -- x )</code></dd>

<dd>
<code>set   ( x inst class -- )</code></dd>

<dd>
<code>.payload   ( inst class -- addr ) </code>member holds instance's
value</dd>

<dt>
<b><code>c-ptr</code></b></dt>

<dd>
Base class derived from <code>object</code> for pointers to non-object types.
This class is not complete by itself: several methods depend on a derived
class definition of <code>@size</code>. Methods &amp; members:</dd>

<dd>
<code>.addr   ( inst class -- a-addr )</code> member variable - holds
the pointer address</dd>

<dd>
<code>get-ptr   ( inst class -- ptr )</code></dd>

<dd>
<code>set-ptr   ( ptr inst class -- )</code></dd>

<dd>
<code>inc-ptr   ( inst class -- )</code> Adds @size to pointer address</dd>

<dd>
<code>dec-ptr   ( inst class -- )</code> Subtracts @size from pointer
address</dd>

<dd>
<code>index-ptr   ( i inst class -- )</code> Adds i*@size to pointer
address</dd>

<dt>
<b><code>c-bytePtr</code></b></dt>

<dd>
Pointer to byte derived from c-ptr. Methods &amp; members:</dd>

<dd>
<code>@size   ( inst class -- size )</code> Push size of the pointed-to
thing</dd>

<dd>
<code>get   (  inst class -- c ) </code>Fetch the pointer's
referent byte</dd>

<dd>
<code>set   ( c inst class -- ) </code>Store c at the pointer address</dd>

<dt>
<b><code>c-2bytePtr</code></b></dt>

<dd>
Pointer to double byte derived from c-ptr. Methods &amp; members:</dd>

<dd>
<code>@size   ( inst class -- size )</code> Push size of the pointed-to
thing</dd>

<dd>
<code>get   (  inst class -- x ) </code>Fetch the pointer's
referent 2byte</dd>

<dd>
<code>set   ( x inst class -- )</code> Store 2byte x at the pointer
address</dd>

<dt>
<b><code>c-4bytePtr</code></b></dt>

<dd>
Pointer to quad-byte derived from c-ptr. Methods &amp; members:</dd>

<dd>
<code>@size   ( inst class -- size )</code> Push size of the pointed-to
thing</dd>

<dd>
<code>get   (  inst class -- x ) </code>Fetch the pointer's
referent 2byte</dd>

<dd>
<code>set   ( x inst class -- )</code> Store 2byte x at the pointer
address</dd>

<dt>
<b><code>c-cellPtr</code></b></dt>

<dd>
Pointer to cell derived from c-ptr. Methods &amp; members:</dd>

<dd>
<code>@size   ( inst class -- size )</code> Push size of the pointed-to
thing</dd>

<dd>
<code>get   (  inst class -- x ) </code>Fetch the pointer's
referent cell</dd>

<dd>
<code>set   ( x inst class -- )</code> Storex at the pointer address</dd>

<dt>
<b><code>c-string</code></b>&nbsp; (see string.fr)</dt>

<dd>
Dynamically allocated string similar to MFC CString (Partial list of methods
follows)</dd>

<dd>
<code>set ( c-addr u 2:this -- )</code> Initialize buffer to the specified string</dd>

<dd>
<code>get ( 2:this -- c-addr u )</code> Return buffer contents as counted string</dd>

<dd>
<code>cat ( c-addr u 2:this -- )</code> Append given string to end of buffer</dd>

<dd>
<code>compare ( 2string 2:this -- n )</code> Return result of lexical compare</dd>

<dd>
<code>type ( 2:this -- )</code> Print buffer to the output stream</dd>

<dd>
<code>hashcode ( 2:this -- x )</code> Return hashcode of string (as in dictionary)</dd>

<dd>
<code>free ( 2:this -- )</code> Release internal buffer</dd>

<dt>
<b><code>c-hashstring</code>&nbsp; </b>(see string.fr)</dt>

<dd>
Derived from c-string. This class adds a hashcode member variable.</dd>
</dl>
</td>
</tr>
</table>

      <HR>
      <H2>
        <A name="parsesteps"></A>Parse Steps
      </H2>

<h3>Overview</h3>
<p>
Ficl 2.05 and later includes an extensible parser chain. Ficl feeds every incoming token
(chunk of text with no internal whitespace) to each step in the parse chain in turn. The
first parse step that successfully matches the token applies semantics to it and returns
a TRUE flag, ending the sequence. If all parse steps fire without a match, ficl prints
an error message and resets the virtual machine. Parse steps can be written in precompiled
code, or in ficl itself, and can be appended to the chain at run-time if you like.
</p>
<p>
More detail:
</p>
<ul>
<li>
If compiling and local variable support is enabled, attempt to find the token in the local
variable dictionary. If found, execute the token's compilation semantics and return
</li>
<li>
Attempt to find the token in the system dictionary. If found, execute the token's semantics
(may be different when compiling than when interpreting) and return
</li>
<li>
If prefix support is enabled (Compile-time constant FICL_WANT_PREFIX in sysdep.h is non-zero),
attempt to match the beginning of the token to the list of known prefixes. If there's a match,
execute the associated prefix method.
</li>
<li>
Attempt to convert the token to a number in the present <code>BASE</code>. If successful, push the
value onto the stack if interpreting, compile it if compiling. Return
</li>
<li>
All previous parse steps failed to recognize the token. Print "<token> not found" and abort
</li>
</ul>
You can add steps to the parse chain, and you can add prefixes.
<h3>Adding Parse Steps</h3>
You can add a parse step in two ways. The first is to write a ficl word that
has the correct stack signature for a parse step:
<pre>
my-parse-step   ( c-addr u -- ??? flag )
</pre>
Where <code>c-addr u</code> are the address and length of the incoming token,
and <code>flag</code> is <code>true</code> if the parse step recognizes the token
and <code>false</code> otherwise.
<br>
Install the parse step using <code>add-parse-step</code>.
A trivial example:
<pre>
: ?silly   ( c-addr u -- flag )
   ." Oh no! Not another  " type cr  true ;
' ?silly add-parse-step
parse-order
</pre>
<p>
The other way to add a parse step is by writing it in C, and inserting it into the
parse chain with:
</p>
<pre>
void ficlAddPrecompiledParseStep(FICL_SYSTEM *pSys, char *name, FICL_PARSE_STEP pStep);
</pre>
Where <code>name</code> is the display name of the parse step in the parse chain (as revealed
by <code>parse-order</code>). Parameter pStep is a pointer to the code for the parse step itself,
and must match the following declaration:
<pre>
typedef int (*FICL_PARSE_STEP)(FICL_VM *pVM, STRINGINFO si);
</pre>
<p>
Upon entry to the parse step, <code>si</code> points to the incoming token. The parse step
must return <code>FICL_TRUE</code> if it succeeds in matching the token, and
<code>FICL_TRUE</code> otherwise. If it succeeds in matching a token, the parse step
applies semantics to it before returning. See <code>ficlParseNumber()</code> in words.c for
an example.
</p>

<h3>Adding Prefixes</h3>
<p>
What's a prefix, anyway? A prefix (contributed by Larry Hastings) is a token that's
recognized as the beginning of another token. Its presence modifies the semantics of
the rest of the token. An example is <code>0x</code>, which causes digits following
it to be converted to hex regardless of the current value of <code>BASE</code>.
</p><p>
Caveat: Prefixes are matched in sequence, so the more of them there are,
the slower the interpreter gets. On the other hand, because the prefix parse step occurs
immediately after the dictionary lookup step, if you have a prefix for a particular purpose,
using it may save time since it stops the parse process.
</p><p>
Each prefix is a ficl word stored in a special wordlist called <code>&lt;prefixes&gt;</code>. When the
prefix parse step (<code>?prefix</code> AKA ficlParsePrefix()) fires, it searches each word
in <code>&lt;prefixes&gt;</code> in turn, comparing it with the initial characters of the incoming
token. If a prefix matches, the parse step returns the remainder of the token to the input stream
and executes the code associated with the prefix. This code can be anything you like, but it would
typically do something with the remainder of the token. If the prefix code does not consume the
rest of the token, it will go through the parse process again (which may be what you want).
</p><p>
Prefixes are defined in prefix.c and in softwords/prefix.fr. The easiest way to add a new prefix is
to insert it into prefix.fr and rebuild the system. You can also add prefixes interactively
by bracketing prefix definitions as follows (see prefix,fr):
</p>
<pre>
start-prefixes  ( defined in prefix.fr )
\ make dot-paren a prefix (create an alias for it in the prefixes list)
: .(  .( ;
: 0b  2 __tempbase ; immediate
end-prefixes
</pre>
<p>
The precompiled word <code>__tempbase</code> is a helper for prefixes that specify a
temporary value of <code>BASE</code>.
</p><p>
Constant <code>FICL_EXTENDED_PREFIX</code> controls the inclusion of a bunch of additional
prefix definitions. This is turned off in the default build since several of these prefixes
alter standard behavior, but you might like them.
</p>

<h3>Notes</h3>
<p>
Prefixes and parser extensions are non-standard, although with the exception of prefix support,
ficl's default parse order follows the standard. Inserting parse steps in some other order
will almost certainly break standard behavior.
</p>
<p>
The number of parse steps that can be added to the system is limited by the value of
<code>FICL_MAX_PARSE_STEPS</code> (defined in sysdep.h unless you define it first), which defaults
to 8. More parse steps means slower average interpret and compile performance,
so be sparing. Same applies to the number of prefixes defined for the system, since each one
has to be matched in turn before it can be proven that no prefix matches. On the other hand,
if prefixes are defined, use them when possible: since they are matched early in the parse order,
a prefix match short circuits the parse process, saving time relative to
(for example) using a number builder parse step at the end of the parse chain.
</p>
<p>
Compile time constant <code>FICL_EXTENDED_PREFIX</code> enables several more prefix
definitions in prefix.c and prefix.fr. Please note that this will slow average compile and
interpret speed in most cases.
</p>
<h3>Parser Glossary</h3>
<dl>
<dt><b><code>parse-order  ( -- )</code></b></dt>
<dd>
Prints the list of parse steps in the order in which they are evaluated.
Each step is the name of a ficl word with the following signature:
<pre>
parse-step   ( c-addr u -- ??? flag )
</pre>
A parse step consumes a counted string (the incoming token) from the stack,
and exits leaving a flag on top of the stack (it may also leave other parameters as side effects).
The flag is true if the parse step succeeded at recognizing the token, false otherwise.
</dd>
<dt><b><code>add-parse-step  ( xt -- )</code></b></dt>
<dd>
Appends a parse step to the parse chain. XT is the adress (execution token) of a ficl
word to use as the parse step. The word must have the following signature:
<pre>
parse-step   ( c-addr u -- ??? flag )
</pre>
A parse step consumes a counted string (the incoming token) from the stack,
and exits leaving a flag on top of the stack (it may also leave other parameters as side effects).
The flag is true if the parse step succeeded at recognizing the token, false otherwise.
</dd>
<dt><b><code>show-prefixes  ( -- )</code></b></dt>
<dd>
Defined in <code>softwords/prefix.fr</code>.
Prints the list of all prefixes. Each prefix is a ficl word that is executed if its name
is found at the beginning of a token. See <code>softwords/prefix.fr</code> and <code>prefix.c</code> for examples.
</dd>
<dt><b><code>start-prefixes  ( -- )</code></b></dt>
<dd>
Defined in <code>softwords/prefix.fr</code>.
Declares the beginning of one or more prefix definitions (it just switches the compile wordlist
to <code>&lt;prefixes&gt;</code>
</dd>
<dt><b><code>end-prefixes  ( -- )</code></b></dt>
<dd>
Defined in <code>softwords/prefix.fr</code>.
Restores the compilation wordlist that was in effect before the last invocation of
<code>start-prefixes</code>. Note: the prior wordlist ID is stored in a Ficl variable, so
attempts to nest <code>start-prefixes end-prefixes</code> blocks wil result in mildly silly
side effects.
</dd>
</dl>

      <HR>
      <H2>
        <A name="debugger"></A>Debugger
      </H2>
<p>Ficl includes a simple step debugger for colon definitions
and <code>does&gt;</code> words. If you use it and can suggest improvements (or better
yet if you write some), please let me know.</p>
<h3>Using the debugger</h3>
To debug a word, set up the stack with any parameters the word requires,
then type:

<pre>debug &lt;your word here></pre>

<p>If the word is unnamed, or all you have is an xt, you can instead use:</p>
<code>debug-xt   ( xt -- )</code>
<p>The debugger invokes <code>see</code> on the word, printing a crude source
listing, then stops at the first instruction of the definition. There are
four (case insensitive) commands you can use from here onwards:</p>

<dl>
<dt>I (step in)</dt>
<dd>If the next instruction is a colon defintion or does> word, steps into
that word's code. If the word is a primitive, simply executes the word.</dd>

<dt>O (step over)</dt>
<dd>Executes the next instruction in its entirety</dd>

<dt>G (go)</dt>
<dd>Run the word to completion and exit the debugger</dd>

<dt>L (list)</dt>
<dd>Lists the source code of the word presently being stepped</dd>

<dt>Q (quit)</dt>
<dd>Abort the word and exit the debugger, clearing the stack</dd>

<dt>X (eXecute)</dt>
<dd>Interpret the remainder of the line as ficl words for their side effects.
Any errors will abort the debug session and reset the VM. Usage example:
<pre>
x drop 3 \ fix argument on stack
</pre>
</dd>

<dt>Anything else</dt>
<dd>Prints a list of available debugger commands</dd>
</dl>

<h3>The on-step event</h3>
<p>If there is a defined word named <code>on-step</code> when the debugger starts, that
word will be executed before every step. As a guideline, this word should
have no side effects. Its intended use is to display the stacks and any other
VM state you're interested in, but you
may have some better ideas. If so, please let me know. The default on-step is:<p>
<code>: on-step  ." S: " .s cr ;</code>

<h3>Other useful words for debugging and on-step</h3>
<dl>
<dt><code>r.s  ( -- )</code></dt>
<dd>Prints a represention of the state of the return stack non-destructively. You have to have
a good understanding of the return stack side-effects of control words to make sense of it,
but it does give an accurate representation of what's there. Example: <code>DO .. LOOP</code>s stack
three parameters on the return stack: the loop count and limit, and the <code>LEAVE</code> target
address.</dd>
<dt><code>.s  ( -- )</code></dt>
<dd>Prints the parameter stack non-destructively</dd>
<dt><code>f.s  ( -- )</code></dt>
<dd>Prints the float stack non-destructively (only available if FICL_WANT_FLOAT is enabled)</dd>
</dl>
<h3>Debugger internals</h3>
<p>
The debugger words are mostly located in source file <code>tools.c</code>. There are
supporting words (<code>debug</code> and <code>on-step</code>) in softcore.fr as well.
There are two main words that make the debugger go: <code>debug-xt</code> and <code>step-break</code>.
<code>Debug-xt</code> takes the xt of a word to debug (as returned by <code>'</code>, for example)
checks to see if it is debuggable (not a primitive), sets a breakpoint at its
first instruction, and runs <code>see</code> on it. To set a breakpoint,
<code>debug-xt</code>
replaces the instruction at the breakpoint with the xt of <code>step-break</code>, and
stores the original instruction and its address in a static breakpoint
record. To clear the breakpoint, <code>step-break</code> simply replaces the original
instruction and adjusts the target virtual machine's instruction pointer
to run it.
</p>
<p><code>Step-break</code> is responsible for processing debugger commands and setting
breakpoints at subsequent instructions.</p>
<h3>To Do</h3>
<ul>
<li>The debugger needs to exit automatically when it encounters the end of the word
it was asked to debug. Perhaps this could be a special kind of breakpoint?
</li>
<li>Add user-set breakpoints</li>
<li>Add "step out" command</li>
</ul>

      <HR>
      <H2>
        <A name="ansinfo"></A>ANS Required Information
      </H2>
      <UL>
        <LI>
          <B>ANS Forth System</B>
        </LI>
        <LI>
          <B>Providing names from the Core Extensions word set&nbsp;</B>
        </LI>
        <LI>
          <B>Providing the Exception word set</B>
        </LI>
        <LI>
          <B>Providing names from the Exception Extensions word set</B>
        </LI>
        <LI>
          <B>Providing the Locals word set&nbsp;</B>
        </LI>
        <LI>
          <B>Providing the Locals Extensions word set&nbsp;</B>
        </LI>
        <LI>
          <B>Providing the Memory Allocation word set</B>
        </LI>
        <LI>
          <B>Providing the Programming-Tools word set</B>
        </LI>
        <LI>
          <B>Providing names from the Programming-Tools Extensions word set</B>
        </LI>
        <LI>
          <B>Providing the Search-Order word set</B>
        </LI>
        <LI>
          <B>Providing the Search-Order Extensions word set</B>
        </LI>
      </UL>
      <H3>
        Implementation-defined Options
      </H3>
      The implementation-defined items in the following list represent characteristics and choices left to the discretion of the implementor, provided that the requirements of the Standard are met. A
      system shall document the values for, or behaviors of, each item.&nbsp;
      <UL>
        <LI>
          <B>aligned address requirements (3.1.3.3 Addresses);</B>&nbsp;
          <BR>
          System dependent. You can change the default address alignment by defining FICL_ALIGN on your compiler's command line. The default value is set to 2 in sysdep.h. This
          causes dictionary entries and <code>ALIGN</code> and <code>ALIGNED</code> to align on 4 byte boundaries. To align on <B>2<SUP>n</SUP></B> byte boundaries, set FICL_ALIGN to <B>n</B>.&nbsp;
        </LI>
        <LI>
          <B>behavior of 6.1.1320 EMIT for non-graphic characters</B>;&nbsp;
          <BR>
          Depends on target system, C runtime library, and your implementation of ficlTextOut().&nbsp;
        </LI>
        <LI>
          <B>character editing of 6.1.0695 ACCEPT and 6.2.1390 EXPECT</B>;&nbsp;
          <BR>
          None implemented in the versions supplied in words.c. Because ficlExec() is supplied a text buffer externally, it's up to your system to define how that buffer will
          be obtained.
        </LI>
        <LI>
          <B>character set (3.1.2 Character types, 6.1.1320 EMIT, 6.1.1750 KEY)</B>;&nbsp;
          <BR>
          Depends on target system and implementation of ficlTextOut().
        </LI>
        <LI>
          <B>character-aligned address requirements (3.1.3.3 Addresses)</B>;&nbsp;
          <BR>
          Ficl characters are one byte each. There are no alignment requirements.
        </LI>
        <LI>
          <B>character-set-extensions matching characteristics (3.4.2 Finding definition names)</B>;&nbsp;
          <BR>
          No special processing is performed on characters beyond case-folding. Therefore, extended characters will not match their unaccented counterparts.
        </LI>
        <LI>
          <B>conditions under which control characters match a space delimiter (3.4.1.1 Delimiters)</B>;&nbsp;
          <BR>
          Ficl uses the Standard C function isspace() to distinguish space characters. The rest is up to your library vendor.&nbsp;
        </LI>
        <LI>
          <B>format of the control-flow stack (3.2.3.2 Control-flow stack)</B>;&nbsp;
          <BR>
          Uses the data stack
        </LI>
        <LI>
          <B>conversion of digits larger than thirty-five (3.2.1.2 Digit conversion)</B>;&nbsp;
          <BR>
          The maximum supported value of <code>BASE</code> is 36. Ficl will assertion fail in function ltoa of vm.c if the base is found to be larger than 36 or smaller than 2.
          There will be no effect if NDEBUG is defined, however, other than possibly unexpected behavior.&nbsp;
        </LI>
        <LI>
          <B>display after input terminates in 6.1.0695 ACCEPT and 6.2.1390 EXPECT</B>;&nbsp;
          <BR>
          Target system dependent
        </LI>
        <LI>
          <B>exception abort sequence (as in 6.1.0680 ABORT")</B>;&nbsp;
          <BR>
          Does <code>ABORT</code>&nbsp;
        </LI>
        <LI>
          <B>input line terminator (3.2.4.1 User input device)</B>;<FONT color="#FF0000">&nbsp;</FONT>
           <BR>
           Target system dependent (implementation of outer loop that calls ficlExec)&nbsp;
        </LI>
        <LI>
          <B>maximum size of a counted string, in characters (3.1.3.4 Counted strings, 6.1.2450 WORD)</B>;&nbsp;
           <BR>
           255&nbsp;
        </LI>
        <LI>
          <B>maximum size of a parsed string (3.4.1 Parsing)</B>;&nbsp;
           <BR>
           Limited by available memory and the maximum unsigned value that can fit in a CELL (2<SUP>32</SUP>-1).&nbsp;
        </LI>
        <LI>
          <B>maximum size of a definition name, in characters (3.3.1.2 Definition names)</B>;&nbsp;
           <BR>
           Ficl stores the first 31 characters of a definition name.
        </LI>
        <LI>
          <B>maximum string length for 6.1.1345 ENVIRONMENT?, in characters</B>;&nbsp;
           <BR>
           Same as maximum definition name length&nbsp;
        </LI>
        <LI>
          <B>method of selecting 3.2.4.1 User input device</B>;&nbsp;
           <BR>
           None supported. This is up to the target system&nbsp;
        </LI>
        <LI>
          <B>method of selecting 3.2.4.2 User output device</B>;&nbsp;
           <BR>
           None supported. This is up to the target system&nbsp;
        </LI>
        <LI>
          <B>methods of dictionary compilation (3.3 The Forth dictionary)</B>;&nbsp;
        </LI>
        <LI>
          <B>number of bits in one address unit (3.1.3.3 Addresses)</B>;&nbsp;
           <BR>
           Target system dependent. Ficl usually supports processors that can address 8 bit quantities, but there is no dependency that I'm aware of.&nbsp;
        </LI>
        <LI>
          <B>number representation and arithmetic (3.2.1.1 Internal number representation)</B>;&nbsp;
          <BR>
          System dependent. Ficl represents a CELL internally as a union that can hold INT32 (a signed 32 bit scalar value), UNS32 (32 bits unsigned), and an untyped pointer. No specific byte
          ordering is assumed.&nbsp;
        </LI>
        <LI>
          <B>ranges for n, +n, u, d, +d, and ud (3.1.3 Single-cell types, 3.1.4 Cell-pair types)</B>;&nbsp;
          <BR>
          Assuming a 32 bit implementation, range for signed single-cell values is -2<SUP>31</SUP>..2<SUP>31</SUP>-1. Range for unsigned single cell values is 0..2<SUP>32</SUP>-1. Range for signed
          double-cell values is -2<SUP>63</SUP>..2<SUP>63</SUP>-1. Range for unsigned single cell values is 0..2<SUP>64</SUP>-1.&nbsp;
        </LI>
        <LI>
          <B>read-only data-space regions (3.3.3 Data space)</B>;
          <BR>
          None&nbsp;
        </LI>
        <LI>
          <B>size of buffer at 6.1.2450 WORD (3.3.3.6 Other transient regions)</B>;&nbsp;
          <BR>
          Default is 255. Depends on the setting of nPAD in ficl.h.&nbsp;
        </LI>
        <LI>
          <B>size of one cell in address units (3.1.3 Single-cell types)</B>;&nbsp;
          <BR>
          System dependent, typically four for 32 bit targets, 8 for 64 bit targets.
        </LI>
        <LI>
          <B>size of one character in address units (3.1.2 Character types)</B>;&nbsp;
           <BR>
           System dependent, usually one.
        </LI>
        <LI>
          <B>size of the keyboard terminal input buffer (3.3.3.5 Input buffers)</B>;&nbsp;
           <BR>
           This buffer is supplied by the host program. Ficl imposes no practical limit.&nbsp;
        </LI>
        <LI>
          <B>size of the pictured numeric output string buffer (3.3.3.6 Other transient regions)</B>;&nbsp;
           <BR>
           Default is 255 characters. Depends on the setting of nPAD in ficl.h.&nbsp;
        </LI>
        <LI>
          <B>size of the scratch area whose address is returned by 6.2.2000 PAD (3.3.3.6 Other transient regions)</B>;&nbsp;
           <BR>
           Not presently supported&nbsp;
        </LI>
        <LI>
          <B>system case-sensitivity characteristics (3.4.2 Finding definition names)</B>;&nbsp;
          <BR>
          Ficl is not case sensitive&nbsp;
        </LI>
        <LI>
          <B>system prompt (3.4 The Forth text interpreter, 6.1.2050 QUIT)</B>;&nbsp;
          <BR>
          "ok&gt;"&nbsp;
        </LI>
        <LI>
          <B>type of division rounding (3.2.2.1 Integer division, 6.1.0100 */, 6.1.0110 */MOD, 6.1.0230 /, 6.1.0240 /MOD, 6.1.1890 MOD)</B>;&nbsp;
           <BR>
           Symmetric rounding (toward zero)&nbsp;
        </LI>
        <LI>
          <B>values of 6.1.2250 STATE when true</B>;&nbsp;
          <BR>
          One (no others)&nbsp;
        </LI>
        <LI>
          <B>values returned after arithmetic overflow (3.2.2.2 Other integer operations)</B>;&nbsp;
           <BR>
           System dependent. Ficl makes no special checks for overflow.&nbsp;
        </LI>
        <LI>
          <B>whether the current definition can be found after 6.1.1250 DOES&gt; (6.1.0450 :)</B>.&nbsp;
           <BR>
           No. Definitions are unsmudged after ; only, and only then if no control structure matching problems have been detected.&nbsp;
        </LI>
      </UL>
      <H3>
        Ambiguous Conditions
      </H3>
      A system shall document the system action taken upon each of the general or specific ambiguous conditions identified in this Standard. See 3.4.4 Possible actions on an ambiguous
      condition.&nbsp;
      <P>
        The following general ambiguous conditions could occur because of a combination of factors:&nbsp;
      </P>
      <UL>
        <LI>
          <B>a name is neither a valid definition name nor a valid number during text interpretation (3.4 The Forth text interpreter)</B>;&nbsp;
           <BR>
           Ficl does <code>ABORT</code> and prints the name followed by " not found".&nbsp;
        </LI>
        <LI>
          <B>a definition name exceeded the maximum length allowed (3.3.1.2 Definition names)</B>;&nbsp;
          <BR>
          Ficl stores the first 31 characters of the definition name, and uses all characters of the name in computing its hash code. The actual length of the name, up to 255
          characters, is stored in the definition's length field.&nbsp;
        </LI>
        <LI>
          <B>addressing a region not listed in 3.3.3 Data Space</B>;&nbsp;
           <BR>
           No problem: all addresses in ficl are absolute. You can reach any address in Ficl's address space.
        </LI>
        <LI>
          <B>argument type incompatible with specified input parameter, e.g., passing a flag to a word expecting an n (3.1 Data types)</B>;&nbsp;
           <BR>
           Ficl makes no check for argument type compatibility. Effects of a mismatch vary widely depending on the specific problem and operands.&nbsp;
        </LI>
        <LI>
          <B>attempting to obtain the execution token, (e.g., with 6.1.0070 ', 6.1.1550 FIND, etc.) of a definition with undefined interpretation semantics</B>;&nbsp;
          <BR>
          Ficl returns a valid token, but the result of executing that token while interpreting may be undesirable.
        </LI>
        <LI>
          <B>dividing by zero (6.1.0100 */, 6.1.0110 */MOD, 6.1.0230 /, 6.1.0240 /MOD, 6.1.1561 FM/MOD, 6.1.1890 MOD, 6.1.2214 SM/REM, 6.1.2370 UM/MOD, 8.6.1.1820 M*/)</B>;
           <BR>
           Results are target procesor dependent. Usually, Ficl makes no check for divide-by-zero. The target processor will throw an exception.&nbsp;
        </LI>
        <LI>
          <B>insufficient data-stack space or return-stack space (stack overflow)</B>;&nbsp;
           <BR>
           With FICL_ROBUST (sysdep.h) set &gt;= 2, most parameter stack operations are checked for underflow and overflow. Ficl does not check the return stack.&nbsp;
        </LI>
        <LI>
          <B>insufficient space for loop-control parameters</B>;&nbsp;
          <BR>
          No check - Evil results.&nbsp;
        </LI>
        <LI>
          <B>insufficient space in the dictionary</B>;&nbsp;
          <BR>
          Ficl generates an error message if the dictionary is too full to create a definition header. It checks <code>ALLOT</code> as well, but it is possible to make an unchecked
          allocation request that overflows the dictionary.&nbsp;
        </LI>
        <LI>
          <B>interpreting a word with undefined interpretation semantics</B>;&nbsp;
          <BR>
          Ficl protects all ANS Forth words with undefined interpretation semantics from being executed while in interpret state. It is possible to defeat this protection using
          ' (tick) and <code>EXECUTE</code>, though.&nbsp;
        </LI>
        <LI>
          <B>modifying the contents of the input buffer or a string literal (3.3.3.4 Text-literal regions, 3.3.3.5 Input buffers)</B>;&nbsp;
          <BR>
          Varies depending on the nature of the buffer. The input buffer is supplied by ficl's host function, and may reside in read-only memory. If so, writing the input
          buffer can ganerate an exception. String literals are stored in the dictionary, and are writable.&nbsp;
        </LI>
        <LI>
          <B>overflow of a pictured numeric output string</B>;
          <BR>
          In the unlikely event you are able to construct a pictured numeric string of more than 255 characters, the system will be corrupted unpredictably. The buffer area that holds pictured
          numeric output is at the end of the virtual machine. Whatever is mapped after the offending VM in memory will be trashed, along with the heap structures that contain it.&nbsp;
        </LI>
        <LI>
          <B>parsed string overflow</B>;
           <BR>
           Ficl does not copy parsed strings unless asked to. Ordinarily, a string parsed from the input buffer during normal interpretation is left in-place, so there is no possibility of overflow.
          If you ask to parse a string into the dictionary, as in <code>SLITERAL</code>, you need to have enough room for the string, otherwise bad things may happen. This is not usually a problem.&nbsp;
        </LI>
        <LI>
          <B>producing a result out of range, e.g., multiplication (using *) results in a value too big to be represented by a single-cell integer (6.1.0090 *, 6.1.0100 */, 6.1.0110 */MOD, 6.1.0570
          &gt;NUMBER, 6.1.1561 FM/MOD, 6.1.2214 SM/REM, 6.1.2370 UM/MOD, 6.2.0970 CONVERT, 8.6.1.1820 M*/)</B>;&nbsp;
           <BR>
           Value will be truncated to fit in a single cell.&nbsp;
        </LI>
        <LI>
          <B>reading from an empty data stack or return stack (stack underflow)</B>;&nbsp;
          <BR>
          Most stack underflows are detected and prevented if FICL_ROBUST (sysdep.h) is set to 2 or greater. Otherwise, the stack pointer and size are likely to be
          trashed.&nbsp;
        </LI>
        <LI>
          <B>unexpected end of input buffer, resulting in an attempt to use a zero-length string as a name</B>;&nbsp;
           <BR>
           Ficl returns for a new input buffer until a non-empty one is supplied.&nbsp;
        </LI>
      </UL>
      The following specific ambiguous conditions are noted in the glossary entries of the relevant words:&nbsp;
      <UL>
        <LI>
          <B>&gt;IN greater than size of input buffer (3.4.1 Parsing)</B>
           <BR>
           Bad Things occur - unpredictable bacause the input buffer is supplied by the host program's outer loop.&nbsp;
        </LI>
        <LI>
          <B>6.1.2120 RECURSE appears after 6.1.1250 DOES&gt;</B>
           <BR>
           It finds the address of the definition before <code>DOES&gt;</code>
        </LI>
        <LI>
          <B>argument input source different than current input source for 6.2.2148 RESTORE-INPUT</B>
           <BR>
           Not implemented&nbsp;
        </LI>
        <LI>
          <B>data space containing definitions is de-allocated (3.3.3.2 Contiguous regions)</B>
           <BR>
           This is OK until the cells are overwritten with something else. The dictionary maintains a hash table, and the table must be updated in order to de-allocate words without corruption.&nbsp;
        </LI>
        <LI>
          <B>data space read/write with incorrect alignment (3.3.3.1 Address alignment)</B>
           <BR>
           Target processor dependent. Consequences include: none (Intel), address error exception (68K).&nbsp;
        </LI>
        <LI>
          <B>data-space pointer not properly aligned (6.1.0150 ,, 6.1.0860 C,)</B>
           <BR>
           See above on data space read/write alignment&nbsp;
        </LI>
        <LI>
          <B>less than u+2 stack items (6.2.2030 PICK, 6.2.2150 ROLL)</B>
           <BR>
           Ficl detects a stack underflow and reports it, executing <code>ABORT,</code> as long as FICL_ROBUST is two or larger.&nbsp;
        </LI>
        <LI>
          <B>loop-control parameters not available ( 6.1.0140 +LOOP, 6.1.1680 I, 6.1.1730 J, 6.1.1760 LEAVE, 6.1.1800 LOOP, 6.1.2380 UNLOOP)</B>
          <BR>
          Loop initiation words are responsible for checking the stack and guaranteeing that the control parameters are pushed. Any underflows will be detected early if FICL_ROBUST is set to two or
          greater. Note however that Ficl only checks for return stack underflows at the end of each line of text.&nbsp;
        </LI>
        <LI>
          <B>most recent definition does not have a name (6.1.1710 IMMEDIATE)</B>
           <BR>
           No problem.&nbsp;
        </LI>
        <LI>
          <B>name not defined by 6.2.2405 VALUE used by 6.2.2295 TO</B>
           <BR>
           Ficl's version of <code>TO</code> works correctly with <code>VALUE</code>s, <code>CONSTANT</code>s and <code>VARIABLE</code>s.&nbsp;
        </LI>
        <LI>
          <B>name not found (6.1.0070 ', 6.1.2033 POSTPONE, 6.1.2510 ['], 6.2.2530 [COMPILE])</B>
           <BR>
           Ficl prints an error message and does <code>ABORT</code>
        </LI>
        <LI>
          <B>parameters are not of the same type (6.1.1240 DO, 6.2.0620 ?DO, 6.2.2440 WITHIN)</B>
           <BR>
           No check. Results vary depending on the specific problem.&nbsp;
        </LI>
        <LI>
          <B>6.1.2033 POSTPONE or 6.2.2530 [COMPILE] applied to 6.2.2295 TO</B>
           <BR>
           The word is postponed correctly.&nbsp;
        </LI>
        <LI>
          <B>string longer than a counted string returned by 6.1.2450 WORD</B>
           <BR>
           Ficl stores the first FICL_STRING_MAX-1 chars in the destination buffer. (The extra character is the trailing space required by the standard. Yuck.)&nbsp;
        </LI>
        <LI>
          <B>u greater than or equal to the number of bits in a cell (6.1.1805 LSHIFT, 6.1.2162 RSHIFT)</B>
           <BR>
           Depends on target process or and C runtime library implementations of the &lt;&lt; and &gt;&gt; operators on unsigned values. For I386, the processor appears to shift modulo the number of
          bits in a cell.&nbsp;
        </LI>
        <LI>
          <B>word not defined via 6.1.1000 CREATE (6.1.0550 &gt;BODY, 6.1.1250 DOES&gt;)</B>
        </LI>
        <LI>
           <B>words improperly used outside 6.1.0490 &lt;# and 6.1.0040 #&gt; (6.1.0030 #, 6.1.0050 #S, 6.1.1670 HOLD, 6.1.2210 SIGN)</B>
           <BR>
           Don't. <code>CREATE</code> reserves a field in words it builds for <code>DOES&gt;</code>to fill in. If you use <code>DOES&gt;</code> on a word not made by <code>CREATE</code>, it will overwrite the first
          cell of its parameter area. That's probably not what you want. Likewise, pictured numeric words assume that there is a string under construction in the VM's scratch buffer. If that's not
          the case, results may be unpleasant.
        </LI>
      </UL>
      <H3>
        Locals Implementation-defined options
      </H3>
      <UL>
        <LI>
          <B>maximum number of locals in a definition (13.3.3 Processing locals, 13.6.2.1795 LOCALS|)</B>
          <BR>
           Default is 16. Change by redefining FICL_MAX_LOCALS, defined in sysdep.h
        </LI>
      </UL>
      <H3>
        Locals Ambiguous conditions
      </H3>
      <UL>
        <LI>
          <B>executing a named local while in interpretation state (13.6.1.0086 (LOCAL))</B>
          <BR>
           Locals can be found in interpretation state while in the context of a definition under construction. Under these circumstances, locals behave correctly. Locals are not visible at all
          outside the scope of a definition.&nbsp;
        </LI>
        <LI>
          <B>name not defined by VALUE or LOCAL (13.6.1.2295 TO)</B>
          <BR>
           See the CORE ambiguous conditions, above (no change)
        </LI>
      </UL>
      <H3>
        Programming Tools Implementation-defined options
      </H3>
      <UL>
        <LI>
          <B>source and format of display by 15.6.1.2194 SEE</B>
          <BR>
           SEE de-compiles definitions from the dictionary. Because Ficl words are threaded by their header addresses, it is very straightforward to print the name and other characteristics of words
          in a definition. Primitives are so noted. Colon definitions are decompiled, but branch target labels are not reconstructed. Literals and string literals are so noted, and their contents
          displayed.
        </LI>
      </UL>
      <H3>
        Search Order Implementation-defined options
      </H3>
      <UL>
        <LI>
          <B>maximum number of word lists in the search order (16.3.3 Finding definition names, 16.6.1.2197 SET-ORDER)</B>&nbsp;
          <BR>
           Defaults to 16. Can be changed by redefining FICL_DEFAULT_VOCS, declared in sysdep.h&nbsp;
        </LI>
        <LI>
          <B>minimum search order (16.6.1.2197 SET-ORDER, 16.6.2.1965 ONLY)</B>&nbsp;
          <BR>
           Equivalent to <code>FORTH-WORDLIST 1 SET-ORDER</code>
        </LI>
      </UL>
      <H3>
        Search Order Ambiguous conditions
      </H3>
      <UL>
        <LI>
          <B>changing the compilation word list (16.3.3 Finding definition names)</B>
          <BR>
           Ficl stores a link to the current definition independently of the compile wordlist while it is being defined, and links it into the compile wordlist only after the definition completes
          successfully. Changing the compile wordlist mid-definition will cause the definition to link into the <I>new</I> compile wordlist.&nbsp;
        </LI>
        <LI>
          <B>search order empty (16.6.2.2037 PREVIOUS)</B>
          <BR>
           Ficl prints an error message if the search order underflows, and resets the order to its default state.&nbsp;
        </LI>
        <LI>
          <B>too many word lists in search order (16.6.2.0715 ALSO)</B>
          <BR>
           Ficl prints an error message if the search order overflows, and resets the order to its default state.
        </LI>
      </UL>
      </div><!-- .content -->
      </div><!-- .docs-layout -->
    </main>

    <footer class="site-footer">
      <div class="wrap footer-grid">
        <div>Ficl - Forth Inspired Command Language</div>
        <div>Questions or contributions: <a href="https://sourceforge.net/u/jsadler/profile/">John Sadler</a></div>
      </div>
    </footer>
  <script>
  (function () {
    var ids = ["whatis","links","lawyerbait","porting","api","manifest","internals","extras","locals","oop","parsesteps","debugger","ansinfo"];
    var targets = ids.map(function (id) { return document.querySelector('a[name="' + id + '"]'); }).filter(Boolean);
    var links = {};
    document.querySelectorAll("#toc-sidebar a").forEach(function (a) {
      var h = a.getAttribute("href");
      if (h) links[h.slice(1)] = a.parentElement;
    });

    function activate(id) {
      Object.values(links).forEach(function (li) { li.classList.remove("active"); });
      if (links[id]) links[id].classList.add("active");
    }

    var current = ids[0];
    var observer = new IntersectionObserver(function (entries) {
      entries.forEach(function (e) {
        if (e.isIntersecting) {
          var name = e.target.getAttribute("name");
          if (name) { current = name; activate(name); }
        }
      });
    }, { rootMargin: "-96px 0px -60% 0px" });

    targets.forEach(function (t) { observer.observe(t); });
    activate(current);
  })();
  </script>
  </body>
</html>
