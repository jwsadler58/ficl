<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="john sadler">
    <meta name="description" content="Ficl - embedded scripting with object oriented programming">
    <link rel="icon" href="ficl-icon.svg" type="image/svg+xml">
    <link rel="stylesheet" href="styles.css">
    <title>Ficl - Embedded Scripting</title>
  </head>
  <body>
    <header class="site-header">
      <div class="wrap">
        <a class="brand" href="index.html">
          <img class="brand-mark" src="ficl-icon.svg" alt="Ficl logo">
          <div>
            <span class="brand-name">Ficl</span>
            <span class="brand-tag">Forth Inspired Command Language</span>
          </div>
        </a>
        <nav class="site-nav">
          <a href="ficl.html">Docs</a>
          <a href="demo.html">Demo</a>
          <a href="ficl_rel.html">Release Notes</a>
          <a class="nav-cta" href="http://sourceforge.net/project/showfiles.php?group_id=24441">Download</a>
        </nav>
      </div>
    </header>

    <main>
      <section class="page-hero">
        <div class="wrap">
          <p class="eyebrow">Documentation</p>
          <h1>Ficl Documentation</h1>
          <p>Core reference, features, and API details.</p>
        </div>
      </section>

      <div class="wrap content">
      <BR>
      <H2>Contents</H2>
      <UL>
        <LI><A href="#whatis">What is ficl?</A></LI>
        <LI><A href="#links">References</A></LI>
        <LI><A href="#lawyerbait">LICENSE and DISCLAIMER</A></LI>
        <LI><A href="#porting">Getting Started: Porting Ficl to your system</A></LI>
        <LI><A href="#api">Application Programming Interface</A></LI>
        <LI><A href="#manifest">Ficl Source Files</A></LI>
        <LI><A href="#internals">Ficl Internals</A></LI>
        <LI><A href="#extras">Ficl extras</A></LI>
        <LI><A href="#ansinfo">ANS Required Information</A></LI>
      </UL>
       
      <H1>
        <A name="whatis"></A>What is ficl?
      </H1>
      <P>
        Ficl is a lightweight, embeddable scripting language designed to be incorporated 
        into other programs, including memory constrained embedded systems. 
        Ficl conforms to the 1994 ANSI Standard for Forth, and provides several useful 
        extensions including OOP that can wrap compiled code and hardware interfaces.&nbsp;
      </P>
      <P>
        Unlike Lua or Python, Ficl acts as a <I>component</I> of your system: you feed it stuff to do, it does the stuff, and comes back to you for more. 
        You can export compiled code to Ficl, execute Ficl code from your compiled code, or interact with a read-execute-print loop. 
        Your choice. 
        Ficl includes a simple but capable object model that can wrap existing data structures.&nbsp;
      </P>
      <H3>
        Ficl vs. other Interpreters
      </H3>
      Where language interpreters usually view themselves as the center of the system, Ficl acts as a component of the system. It is easy to export compiled code
      to Ficl in the style of TCL, or to invoke Ficl code from a compiled module. This allows you to do incremental development in a way that combines the best features of
      threaded languages (rapid development, quick code/test/debug cycle, reasonably fast) with the best features of C (everyone knows it, easier to support large blocks of code, efficient, type
      checking). In addition, Ficl provides a simple and powerful object model that can act as an object oriented <I>adapter</I> for code written in C/C++.&nbsp; 
      <H3>
        Ficl Design goals
      </H3>
      <UL>
        <LI>
          Scripting, prototyping, and extension language for systems written also in C/C++
        </LI>
        <LI>
          Target 32 & 64 bit processors, including embedded systems with limited memory
        </LI>
        <LI>
          Wrap functions and data structures written in C/C++
        </LI>
        <LI>
          Conform to the Forth DPANS 94
        </LI>
        <LI>
          Minimize porting effort - require an ANSI C runtime environment and minimal glue code
        </LI>
        <LI>
          Provide Object Oriented extensions that can wrap system functions and structures
        </LI>
      </UL>
      <HR>
      <H2>
        <A name="links"></A>References: More information on Ficl
      </H2>
      <UL>
        <LI>
          <A href="http://ficl.sourceforge.net">Web home of Ficl</A>
        </LI>
        <LI>
          <A href="ficl.html#internals">Ficl Internals</A>
        </LI>
        <LI>
          <A href="ficl_oop.html">Ficl OOP extension</A>
        </LI>
        <LI>
          <A href="ficl_parse.html">Prefix parser extension</A>
        </LI>
        <LI>
          <A href="ficl_loc.html">Local variable extension</A>
        </LI>
        <LI>
          <A href="ficl_debug.html">Debugger</A>
        </LI>
        <LI>
          <A href="oo_in_c.html">OO in C background notes</A>
        </LI>
        <LI>
          <A href="ficlddj.pdf">Manuscript of Ficl article for January 1999 Dr. Dobb's Journal</A>
        </LI>
        <LI>
          <A href="jwsforml.pdf">1998 FORML Conference paper - OO Programming in Ficl</A>
        </LI>
      </UL>
      <H2>
        Forth and Threaded Interpretive Languages
      </H2>
      <UL>
        <LI>
          <A href="http://www.taygeta.com/forth_intro/stackflo.html">An Introduction to Forth using Stack Flow</A> (start here if you're new to Forth)
        </LI>
        <LI>
          <A href="http://www.softsynth.com/pforth/pf_tut.htm">Phil Burk's Forth Tutorial</A>
        </LI>
        <LI>
          <A href="http://ficl.sourceforge.net/pdf/Forth_Primer.pdf">An excellent Forth Primer by Hans Bezemer</A>
        </LI>
        <LI>
          <A href="http://www.complang.tuwien.ac.at/forth/threaded-code.html">Anton Ertl's description of Threaded Code</A>
        </LI>
        <LI>
          <A href="http://ficl.sourceforge.net/dpans/dpans.htm">Draft Proposed American National Standard for Forth</A> surprisingly readable
        </LI>
        <LI>
          <A href="http://www.taygeta.com/forthlit.html">Forth literature index on Taygeta</A>
        </LI>
        <LI>
          <A href="http://www.forth.org">Forth Interest Group</A>
        </LI>
      </UL>
      <HR>
      <H2>
        <A name="lawyerbait"></A>LICENSE and DISCLAIMER
      </H2>
      <P>
        Copyright (c) 1997-2026 John Sadler, All rights reserved.
      </P>
      <P>
        I am interested in hearing from anyone who uses ficl. If you have a problem, a success story, a defect, an enhancement request, or if you would like to contribute to a ficl release, please
        contact me on Sourceforge.&nbsp;
      </P>
<PRE>
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. Neither the name of the copyright holder nor the names of its contributors
   may be used to endorse or promote products derived from this software 
   without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
</PRE>
      &nbsp; 
      <HR>
      <H2>
        <A name="porting"></A>Getting Started: Porting Ficl to your system
      </H2>
      To install ficl on your target system, you need an ANSI C compiler (C11 or newer) and its runtime library. 
      System dependent code is isolated to a few functions that you need to implement for your system. See sysdep.h for build controls.&nbsp;
      <P>
        Edit the definitions (in sysdep.c) of <TT>ficlMalloc, ficlFree, ficlRealloc</TT>, and <TT>ficlTextOut</TT> for your application and target. 
        Use <TT>testmain.c</TT> as a guide to installing the ficl system and one or more virtual machines into your code.&nbsp;
      </P> 
      <P>
        Ficl includes portable double precision math routines that work for 32 and 64 bit machines. 
        You may replace them with machine-dependent versions by #defining PORTABLE_LONGMULDIV to 0 in sysdep.h and 
        implementing your versions of ficlLongMul and ficlLongDiv in sysdep.c.
        &nbsp;
      </P>
      <H3>
        Build controls
      </H3>
      The file sysdep.h contains default values for build controls. Most of these are written such that if you define them on the compiler command line, the defaults are overridden. I suggest you
      take the defaults on everything below the "build controls" section until you're confident of your port. Beware of declaring too small a dictionary, for example. You need about 3200 cells for a
      full system, about 2000 if you strip out the softwords.&nbsp; 
      <H3>
        Softwords
      </H3>
      Many words from the supported wordsets are written in Forth and stored as a big string that Ficl compiles when it starts. The sources for all of these words are in directory
      ficl/softwords. There is a Python 3 script (softcore.py) that converts the .fr files into softcore.c.
      See the makefile in ficl/softwords.&nbsp; 
      <HR>
      <H2>
        <A name="api"></A>Application Programming Interface
      </H2>
      The following is a partial listing of functions that interface your system or program to ficl. For a complete listing, see ficl.h (heavily commented). For examples, see testmain.c and the
      ficlwin sources (<A href="#download">below</A>). <I>See the comments in ficl.c and ficl.h for additional information, and the example in file testmain.c.</I> 
      <DL>
        <DT>
          <B>FICL_SYSTEM *ficlInitSystem(int nDictCells)</B>
        </DT>
        <DD>
          Initializes Ficl's shared system data structures, and creates the dictionary allocating the specified number of CELLs from the heap (by a call to ficlMalloc)
        </DD>
        <DT>
          <B>void ficlTermSystem(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Reclaims memory allocated for the ficl system including all dictionaries and all virtual machines created by vmCreate. Any uses of the memory allocation words (allocate and resize) are your
          problem.
        </DD>
        <DT>
          <B>int ficlBuild(FICL_SYSTEM *pSys, char *name, FICL_CODE code, char flags)</B>
        </DT>
        <DD>
          Create a primitive word in ficl's main dictionary with the given name, code pointer, and properties (immediate, compile only, etc) as described by the flags (see ficl.h for flag
          descriptions of the form FW_XXXX)
        </DD>
        <DT>
          <B>int ficlExec(FICL_VM *pVM, char *text)</B>
        </DT>
        <DD>
          Feed the specified C string ('\0' terminated) to the given virtual machine for evaluation. Returns various exception codes (VM_XXXX in ficl.h) to indicate the reason for returning. Normal
          exit condition is VM_OUTOFTEXT, indicating that the VM consumed the string successfully and is back for more. ficlExec calls can be nested, and the function itself is re-entrant, but note
          that a VM is static, so you have to take reasonable precautions (for example, use one VM per thread in a multithreaded system if you want multiple threads to be able to execute commands).
        </DD>
        <DT>
          <B>int ficlExecC(FICL_VM *pVM, char *text, int nChars)</B>
        </DT>
        <DD>
          Same as ficlExec, but takes a count indicating the length of the supplied string. Setting nChars to -1 is equivalent to ficlExec (expects '\0' termination).
        </DD>
        <DT>
          <B>int ficlExecXT(FICL_VM *pVM, FICL_WORD *pFW)</B>
        </DT>
        <DD>
          Same as ficlExec, but takes a pointer to a FICL_WORD instead of a string. Executes the word and returns after it has finished. If executing the word results in an exception, this function
          will re-throw the same code if it is nested under another ficlExec family function, or return the exception code directly if not. This function is useful if you need to execute the same
          word repeatedly - you save the dictionary search and outer interpreter overhead.
        </DD>
        <DT>
          <B>void ficlFreeVM(FICL_VM *pVM)</B>
        </DT>
        <DD>
          Removes the VM in question from the system VM list and deletes the&nbsp; memory allocated to it. This is an optional call, since ficlTermSystem will do this cleanup for you. This function
          is handy if you're going to do a lot of dynamic creation of VMs.
        </DD>
        <DT>
          <B>FICL_VM *ficlNewVM(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Create, initialize, and return a VM from the heap using ficlMalloc. Links the VM into the system VM list for later reclamation by ficlTermSystem.
        </DD>
        <DT>
          <B>FICL_WORD *ficlLookup(FICL_SYSTEM *pSys, char *name)</B>
        </DT>
        <DD>
          Returns the address (also known as an XT in this case) of the specified word in the main dictionary. If not found, returns NULL. The address can be used in a call to ficlExecXT.
        </DD>
        <DT>
          <B>FICL_DICT *ficlGetDict(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Returns a pointer to the main system dictionary, or NULL if the system is uninitialized.
        </DD>
        <DT>
          <B>FICL_DICT *ficlGetEnv(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Returns a pointer to the environment dictionary. This dictionary stores information that describes this implementation as required by the Standard.
        </DD>
        <DT>
          <B>void ficlSetEnv(FICL_SYSTEM *pSys, char *name, UNS32 value)</B>
        </DT>
        <DD>
          Enters a new constant into the environment dictionary, with the specified name and value.
        </DD>
        <DT>
          <B>void ficlSetEnvD(FICL_SYSTEM *pSys, char *name, UNS32 hi, UNS32 lo)</B>
        </DT>
        <DD>
          Enters a new double-cell constant into the environment dictionary with the specified name and value.
        </DD>
        <DT>
          <B>FICL_DICT *ficlGetLoc(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Returns a pointer to the locals dictionary. This function is defined only if FICL_WANT_LOCALS is #defined as non-zero (see sysdep.h). The locals dictionary is the symbol table for <A href= 
          "ficl_loc.html">local variables</A>.
        </DD>
        <DT>
          <B>void ficlCompileCore(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Defined in words.c, this function builds ficl's primitives.&nbsp;
        </DD>
        <DT>
          <B>void ficlCompileSoftCore(FICL_SYSTEM *pSys)</B>
        </DT>
        <DD>
          Defined in softcore.c, this function builds ANS required words and ficl extras by evaluating a text string. Python3 script softcore.py 
          generates the string in softcore.c from .fr files in ficl/softcore. &nbsp;
        </DD>
      </DL>
      <HR>
      <TABLE border="0" cellspacing="5" cols="2">
        <TR>
          <TD colspan="2">
            <H2>
              <A name="manifest"></A>Ficl Source Files
            </H2>
          </TD>
        </TR>
        <TR>
          <TD>
            <B>ficl.h</B>
          </TD>
          <TD>
            Declares most public functions and all data structures. Includes sysdep.h and math.h
          </TD>
        </TR>
        <TR>
          <TD>
            <B>sysdep.h</B>
          </TD>
          <TD>
            Declares system dependent functions and contains build control macros. Edit this file to suit your target.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>dpmath.h</B>
          </TD>
          <TD>
            Declares functions for double precision integer math. 
            Sizes automatically to 128 bits on a 64 bit machine or 64 bits on a 32 bit machine
          </TD>
        </TR>
        <TR>
          <TD>
            <B>dict.c</B>
          </TD>
          <TD>
            Dictionary
          </TD>
        </TR>
        <TR>
          <TD>
            <B>ficl.c</B>
          </TD>
          <TD>
            System initialization, termination, and ficlExec
          </TD>
        </TR>
        <TR>
          <TD>
            <B>float.c</B>
          </TD>
          <TD>
            Adds precompiled definitions from the optional FLOAT word set. Most of the file is conditioned on FICL_WANT_FLOAT
          </TD>
        </TR>
        <TR>
          <TD>
            <B>dpmath.c</B>
          </TD>
          <TD>
            Double precision integer math support, including portable versions of ficlLongMul and ficlLongDiv
          </TD>
        </TR>
        <TR>
          <TD>
            <B>prefix.c</B>
          </TD>
          <TD>
            The optional prefix parse step (conditioned on FICL_EXTENDED_PREFIX). This parse step handles numeric constructs like 0xa100, for example. See the release notes for more on parse steps.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>search.c</B>
          </TD>
          <TD>
            Contains C implementations of several of the SEARCH and SEARCH EXT words
          </TD>
        </TR>
        <TR>
          <TD>
            <B>softcore.c</B>
          </TD>
          <TD>
            Contains all of the "soft" words - those written in Forth and compiled by Ficl at startup time. Sources for these words are in the softwords directory. The files softwords/softcore.bat
            and softwords/softcore.pl generate softcore.c from the .fr sources.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>softwords/</B>
          </TD>
          <TD>
            Directory contains sources and translation scripts for the words defined in softcore.c. Softcore.c depends on most of the files in this directory. See softcore.bat for the actual list of
            files that contribute to softcore.c. This is where you'll find source code for the object oriented extensions. PERL script softcore.pl converts the .fr files into softcore.c.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>stack.c</B>
          </TD>
          <TD>
            Stack methods
          </TD>
        </TR>
        <TR>
          <TD>
            <B>sysdep.c</B>
          </TD>
          <TD>
            Target dependent functions declared in sysdep.h. Edit this file to suit your target system.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>testmain.c</B>
          </TD>
          <TD>
            The main() function for console applications - use this as an example to integrate ficl into your system. 
            Also runs unit tests and adds a few handy OS interface words.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>tools.c</B>
          </TD>
          <TD>
            Contains C implementations of TOOLS and TOOLS EXT words, the debugger, and debugger support words.
          </TD>
        </TR>
        <TR>
          <TD>
            <B>vm.c</B>
          </TD>
          <TD>
            Virtual Machine methods
          </TD>
        </TR>
        <TR>
          <TD>
            <B>unix.c</B>
          </TD>
          <TD>
            Platform extensions words loaded in ficl.c by ficlCompilePlatform() - conditioned on FICL_WANT_PLATFORM
          </TD>
        </TR>
        <TR>
          <TD>
            <B>words.c</B>
          </TD>
          <TD>
            Exports ficlCompileCore(), the run-time dictionary builder, and contains most precompiled CORE and CORE-EXT words.
          </TD>
        </TR>
      </TABLE>
      <HR>
      <H2>
        <A name="internals"></A>Ficl Internals
      </H2>
      <!-- BEGIN FICL_GUTS -->
<h2>Major Data Structures</h2>
<p>
A running memory image of Ficl consists of one or more FICL_SYSTEMs, 
each of which owns exactly one dictionary (FICL_DICT), 
and one or more virtual machines (FICL_VM). Each VM owns two stacks
(FICL_STACK) - one for parameters (the parameter stack) 
and one for return addresses (the return stack). 
Ficl is a permissive, untyped language by nature, 
so its fundamental unit of storage is a CELL: a chunk of memory
large enough to hold an address or a scalar type.
</p>
<svg viewBox="0 0 900 400" width="100%" height="auto" role="img" aria-labelledby="ficl-structures-title ficl-structures-desc" style="font-family: inherit; font-size: 14px;">
  <title id="ficl-structures-title">Ficl major data structures</title>
  <desc id="ficl-structures-desc">Diagram showing FICL_SYSTEM owning a dictionary and multiple virtual machines. Each VM owns parameter, return, and optional float stacks. The dictionary contains wordlists, FICL_WORD entries, and cell payloads.</desc>
  <defs>
    <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto" markerUnits="strokeWidth">
      <path d="M0,0 L10,5 L0,10 z" fill="#333"></path>
    </marker>
  </defs>
  <rect x="360" y="20" width="180" height="60" rx="10" fill="#f7f7f7" stroke="#333"></rect>
  <text x="450" y="55" text-anchor="middle" fill="#111">FICL_SYSTEM</text>

  <rect x="172" y="132" width="200" height="60" rx="10" fill="#f1f1f1" stroke="#333"></rect>
  <rect x="166" y="126" width="200" height="60" rx="10" fill="#f4f4f4" stroke="#333"></rect>
  <rect x="160" y="120" width="200" height="60" rx="10" fill="#f7f7f7" stroke="#333"></rect>
  <text x="260" y="155" text-anchor="middle" fill="#111">FICL_VM</text>

  <rect x="60" y="300" width="120" height="50" rx="8" fill="#ffffff" stroke="#333"></rect>
  <text x="120" y="330" text-anchor="middle" fill="#111">param stack</text>
  <rect x="200" y="300" width="120" height="50" rx="8" fill="#ffffff" stroke="#333"></rect>
  <text x="260" y="330" text-anchor="middle" fill="#111">return stack</text>
  <rect x="340" y="300" width="120" height="50" rx="8" fill="#ffffff" stroke="#333" stroke-dasharray="4 3"></rect>
  <text x="400" y="325" text-anchor="middle" fill="#111">float stack</text>
  <text x="400" y="345" text-anchor="middle" fill="#666">(optional)</text>

  <rect x="550" y="120" width="200" height="60" rx="10" fill="#f7f7f7" stroke="#333"></rect>
  <text x="650" y="155" text-anchor="middle" fill="#111">FICL_DICT</text>

  <rect x="562" y="232" width="200" height="50" rx="8" fill="#f1f1f1" stroke="#333"></rect>
  <rect x="556" y="226" width="200" height="50" rx="8" fill="#f4f4f4" stroke="#333"></rect>
  <rect x="550" y="220" width="200" height="50" rx="8" fill="#ffffff" stroke="#333"></rect>
  <text x="650" y="250" text-anchor="middle" fill="#111">FICL_WORDLIST</text>
  <rect x="562" y="302" width="200" height="50" rx="8" fill="#f1f1f1" stroke="#333"></rect>
  <rect x="556" y="296" width="200" height="50" rx="8" fill="#f4f4f4" stroke="#333"></rect>
  <rect x="550" y="290" width="200" height="50" rx="8" fill="#ffffff" stroke="#333"></rect>
  <text x="650" y="320" text-anchor="middle" fill="#111">FICL_WORD</text>

  <line x1="450" y1="80" x2="260" y2="120" stroke="#333" marker-end="url(#arrow)"></line>
  <line x1="450" y1="80" x2="650" y2="120" stroke="#333" marker-end="url(#arrow)"></line>
  <text x="280" y="110" text-anchor="middle" fill="#444">owns</text>
  <text x="570" y="110" text-anchor="middle" fill="#444">owns</text>

  <line x1="260" y1="180" x2="120" y2="300" stroke="#333" marker-end="url(#arrow)"></line>
  <line x1="260" y1="180" x2="260" y2="300" stroke="#333" marker-end="url(#arrow)"></line>
  <line x1="260" y1="180" x2="400" y2="300" stroke="#333" marker-end="url(#arrow)"></line>
  <text x="220" y="255" text-anchor="middle" fill="#444">owns</text>

  <line x1="650" y1="180" x2="650" y2="220" stroke="#333" marker-end="url(#arrow)"></line>
  <line x1="650" y1="270" x2="650" y2="290" stroke="#333" marker-end="url(#arrow)"></line>
  <text x="690" y="210" text-anchor="start" fill="#444">contains</text>
</svg>

<h3>FICL_SYSTEM</h3>
The system structure associates one or more virtual machines with a dictionary. All FICL_SYSTEMS
include a link pointer that is used to keep track of every allocated system so that memory
can be freed by ficlTermSystem. Each system contains a list of virtual machines associated with
it. Each system has at least one virtual machine. In a typical implementation, there is one virtual
machine per native OS thread, and there may be several VMs sharing a single FICL_SYSTEM, or one
FICL_SYSTEM per VM if the implementation needs to support multiple user sessions in a robust way.

A FICL_SYSTEM also includes a special dictionary for local variable support (if enabled 
by FICL_WANT_LOCALS) and another for environment variable support. Environment variables 
describe the configuration of the system in conformance with American National Standard Forth 
(ANS Forth).
<h3>FICL_DICT</h3>
A dictionary manages a fixed-size block of contiguous memory. It serves two roles: to keep track 
of allocated memory, and to collect symbol tables called wordlists. Each dictionary contains at
least one wordlist. The dictionary organized memory (perhaps this is too kind) as an array of
CELLs that grows from low memory to high memory within fixed limits determined by the 
FICL_DEFAULT_DICT parameter in sysdep.h. 

A wordlist is the controlling structure of a Ficl symbol table. Each wordlist is a hash table 
containing pointers to FICL_WORDs. Each FICL_WORD associates a pointer to code with one or more
CELLs of the dictionay. Each word usually has a name as well, but this is not required. It is
possible to create anonymous words using :NONAME.

Each word's code pointer determines that word's runtime behavior, and by implication the purpose
of its payload data. Some words interpret their payload as a list of Ficl words, and execute them.
This is how new behaviors of the language are defined. Other words view their payload field as
a location in which one or more CELLs can be stored (VARIABLEs, for example). At runtime, such
words push the address of their payload area onto the parameter stack.
<h3>FICL_VM</h3>
The virtual machine collects state related to execution of Ficl words. Each VM includes
registers used by the inner interpreter, some state variables (AKA user variables) such as
the current numeric base, and a jmpbuf.
A VM has a pointer to the FICL_SYSTEM of which it is a part. It also has a pointer to an incoming 
text string that it is interpreting. There are VM methods that excute a word given its address
(xt), and ones that interpret a text string. 
<h3>FICL_STACK</h3>
Each VM owns a parameter stack, a return stack, and if float support is enabled, a float parameter
stack. Parameters, return addresses, and floats are all CELL sized, and values may be
moved back and forth among stacks using various Ficl words for that purpose.&nbsp;
<h2>Inner Interpreter: Example Execution</h2>
<p>
This example shows how the inner interpreter executes a simple colon definition with control flow.
The word below computes a factorial using a counted loop and a running accumulator.
</p>
<pre>
: fact ( n -- n! )
  1 swap 1+ 1 ?DO
    I *
  LOOP
;
</pre>
<p>
Ficl stores colon definitions as a payload of execution tokens (XTs). In simplified form, the
payload for <TT>fact</TT> looks like this:
</p>
<pre>
XT (literal) 1
XT swap
XT (literal) 1
XT +
XT (?do) [exit address]
XT I
XT *
XT (loop) [branch address]
XT (;)
</pre>
<p>
When C code calls <TT>ficlExecXT</TT> with the <TT>fact</TT> word, it sets up a nested exception
frame, pushes the <TT>exit-inner</TT> sentinel on the IP stack, and then enters the inner loop.
The inner loop walks the XT list until <TT>(;)</TT> triggers <TT>VM_INNEREXIT</TT>.
</p>
<p>
If an XT in the payload refers to a colon definition, the inner loop executes
its code like any other word. The callee pushes the current instruction pointer, switches to its
own payload, and returns to the caller when <TT>(;)</TT> pops the saved IP.
</p>
<ul>
  <li>
    <B>Setup</B> Save the current <TT>pState</TT> and <TT>runningWord</TT>, install a new
    <TT>jmp_buf</TT>, and push <TT>pExitInner</TT> onto the IP stack.
  </li>
  <li>
    <B>Execute</B> <TT>vmExecute</TT> positions the IP at the word's payload, then
    <TT>vmInnerLoop</TT> executes XTs in order.
  </li>
  <li>
    <B>Looping</B> <TT>(?do)</TT> initializes the loop parameters, <TT>I</TT> fetches the loop
    index, and <TT>(loop)</TT> advances or exits the loop.
  </li>
  <li>
    <B>Exit</B> <TT>(;)</TT> throws <TT>VM_INNEREXIT</TT>, the inner loop unwinds, and
    <TT>ficlExecXT</TT> restores the previous <TT>pState</TT>.
  </li>
</ul>
      <!-- END FICL_GUTS -->
      <HR>
      <H2>
        <A name="extras"></A>Ficl extras
      </H2>
      <H3>
        <A name="exnumber"></A>Number syntax
      </H3>
      You can precede a number with "0x", as in C, and it will be interpreted as a hex value regardless of the value of <CODE>BASE</CODE>. Likewise, numbers prefixed with "0d" will be interpreted as
      decimal values. Example: 
<PRE>
ok&gt; decimal 123 . cr
123
ok&gt; 0x123 . cr
291
ok&gt; 0x123 x. cr
123
</PRE>
      Note: ficl2.05 and later - this behavior is controlled by the <A href="ficl_parse.html">prefix parser</A> defined in <CODE>prefix.c</CODE>. You can add other prefixes by defining handlers for
      them in ficl or C. 
      <H3>
        <A name="exsearch"></A> The <CODE>SEARCH</CODE> wordset and Ficl extensions
      </H3>
      <P>
        Ficl implements many of the search order words in terms of two primitives called <CODE><A href="#tosearch">&gt;SEARCH</A></CODE> and <CODE><A href="#searchfrom">SEARCH&gt;</A></CODE>. As
        their names suggest (assuming you're familiar with Forth), they push and pop the search order stack.
      </P>
      <P>
        The standard does not appear to specify any conditions under which the search order is reset to a sane state. Ficl resets the search order to its default state whenever <TT>ABORT</TT>
        happens. This includes stack underflows and overflows. <TT>QUIT</TT> does not affect the search order. The minimum search order (set by <TT>ONLY</TT>) is equivalent to
      </P>
<PRE>
FORTH-WORDLIST 1 SET-ORDER
</PRE>
      <P>
        There is a default maximum of 16 wordlists in the search order. This can be changed by redefining FICL_DEFAULT_VOCS (declared in sysdep.h).
      </P>
      <P>
        <B>Note</B>: Ficl resets the search order whenever it does <TT>ABORT</TT>. If you don't like this behavior, just comment out the dictResetSearchOrder() lines in ficlExec().
      </P>
      <DL>
        <DT>
          <A name="tosearch"></A><CODE>&gt;search ( wid -- )</CODE>
        </DT>
        <DD>
          Push <TT>wid</TT> onto the search order. Many of the other search order words are written in terms of the <TT>SEARCH&gt;</TT> and <TT>&gt;SEARCH</TT> primitives. This word can be defined in
          ANS Forth as follows
        </DD>
        <DD>
          <TT>: &gt;search&nbsp;&nbsp; &gt;r get-order 1+ r&gt; swap set-order ;</TT>
        </DD>
        <DT>
          <A name="searchfrom"></A><TT>search&gt;&nbsp;&nbsp; ( -- wid )</TT>
        </DT>
        <DD>
          Pop <TT>wid</TT> off the search order (can be coded in ANS Forth as&nbsp;<TT>: search&gt;&nbsp; get-order nip 1- set-order ;</TT> )
        </DD>
        <DT>
          <A name="ficlsetcurrent"></A><TT>ficl-set-current&nbsp;&nbsp; ( wid -- old-wid )</TT>
        </DT>
        <DD>
          Set wid as compile wordlist, leaving the previous compile wordlist on the stack
        </DD>
        <DT>
          <A name="ficlvocabulary"></A><TT>ficl-vocabulary&nbsp;&nbsp; ( nBins "name" -- )</TT>
        </DT>
        <DD>
          Creates a <TT>ficl-wordlist</TT> with the specified number of hash table bins, binds it to the name, and associates the semantics of <TT>vocabulary</TT> with it (replaces the top wid in the
          search order list with its own wid when executed)
        </DD>
        <DT>
          <A name="ficlwordlist"></A><TT>ficl-wordlist&nbsp;&nbsp; ( nBins -- wid )</TT>
        </DT>
        <DD>
          Creates a wordlist with the specified number of hash table bins, and leaves the address of the wordlist on the stack. A <TT>ficl-wordlist</TT> behaves exactly as a regular wordlist, but it
          may search faster depending on the number of bins chosen and the number of words it contains at search time. As implemented in ficl, a wordlist is single threaded by default. <TT>
          ficl-named-wordlist</TT> takes a name for the wordlist and creates a word that pushes the <TT>wid</TT>. This is by contrast to <TT>VOCABULARY</TT>, which also has a name, but replaces the
          top of the search order with its <TT>wid</TT>.
        </DD>
        <DT>
          <A name="ficlforgetwid"></A><TT>forget-wid&nbsp;&nbsp; ( wid -- )</TT>
        </DT>
        <DD>
          Iterates through the specified wordlist and unlinks all definitions whose xt addresses are greater than or equal to the value of <TT>HERE</TT>, the dictionary fill pointer.&nbsp;
        </DD>
        <DT>
          <A name="ficlhide"></A><TT>hide&nbsp;&nbsp; ( -- current-wid-was )</TT>
        </DT>
        <DD>
          Push the <TT>hidden</TT> wordlist onto the search order, and set it as the current compile wordlist (unsing <TT>ficl-set-current</TT>). Leaves the previous compile wordlist ID. I use this
          word to hide implementation factor words that have low reuse potential so that they don't clutter the default wordlist. To undo the effect of hide, execute&nbsp; <B><TT>previous
          set-current</TT></B>
        </DD>
        <DT>
          <A name="ficlhidden"></A><TT>hidden&nbsp;&nbsp; ( -- wid )</TT>
        </DT>
        <DD>
          Wordlist for storing implementation factors of ficl provided words. To see what's in there, try:&nbsp; <B><TT>hide words previous set-current</TT></B>
        </DD>
        <DT>
          <A name="wid-get-name"></A><TT>wid-get-name&nbsp;&nbsp; ( wid -- c-addr u )</TT>
        </DT>
        <DD>
          Ficl wordlists (2.05 and later) have a name property that can be assigned. This is used by <TT>ORDER</TT> to list the names of wordlists in the search order.&nbsp;
        </DD>
        <DT>
          <A name="wid-set-name"></A><TT>wid-set-name&nbsp;&nbsp; ( c-addr wid -- )</TT>
        </DT>
        <DD>
          Ficl wordlists (2.05 and later) have a name property that can be assigned. This is used by <TT>ORDER</TT> to list the names of wordlists in the search order. The name is assumed to be a \0
          terminated string (C style), which conveniently is how Ficl stores word names.&nbsp; See softwords/softcore.fr definition of <TT>brand-wordlist</TT>&nbsp;
        </DD>
        <DT>
          <A name="wid-set-super"></A><TT>wid-set-super&nbsp;&nbsp; ( wid -- )</TT>
        </DT>
        <DD>
          Ficl wordlists have a parent wordlist pointer that is not specified in standard Forth. Ficl initializes this pointer to NULL whenever it creates a wordlist, so it ordinarily has no effect.
          This word sets the parent pointer to the wordlist specified on the top of the stack. Ficl's implementation of <TT>SEARCH-WORDLIST</TT> will chain backward through the parent link of the
          wordlist when searching. This simplifies Ficl's object model in that the search order does not need to reflect an object's class hierarchy when searching for a method. It is possible to
          implement Ficl object syntax in strict ANS Forth, but method finders need to manipulate the search order explicitly.
        </DD>
      </DL>
      <H3>
        <A name="exuser"></A>User variables
      </H3>
      <DL>
        <DT>
          <TT>user&nbsp;&nbsp; ( -- ) name</TT>
        </DT>
        <DD>
          Create a user variable with the given name. User variables are virtual machine local. Each VM allocates a fixed amount of storage for them. You can change the maximum number of user
          variables allowed by defining FICL_USER_CELLS on your compiiler's command line. Default is 16 user cells. User variables behave like <TT>VARIABLE</TT>s in all other respects (you use @ and
          ! on them, for example). Example:
        </DD>
        <DD>
          <DL>
            <DD>
              <TT>user current-class</TT>
            </DD>
            <DD>
              <TT>0 current-class !</TT>
            </DD>
          </DL>
        </DD>
      </DL>
      <H3>
        <A name="exmisc"></A>Miscellaneous
      </H3>
      <DL>
        <DT>
          <TT>-roll&nbsp;&nbsp; ( xu xu-1 ... x0 u -- x0 xu-1 ... x1 )&nbsp;</TT>
        </DT>
        <DD>
          Rotate u+1 items on top of the stack after removing u. Rotation is in the opposite sense to <TT>ROLL</TT>
        </DD>
      </DL>
      <DL>
        <DT>
          <A name="minusrot"></A><TT>-rot&nbsp;&nbsp; ( a b c -- c a b )</TT>
        </DT>
        <DD>
          Rotate the top three stack entries, moving the top of stack to third place. I like to think of this as <TT>1<SUP>1</SUP>/<SUB>2</SUB>swap</TT> because it's good for tucking a single cell
          value behind a cell-pair (like an object).&nbsp;
        </DD>
      </DL>
      <DL>
        <DT>
          <TT>.env&nbsp;&nbsp; ( -- )</TT>
        </DT>
        <DD>
          List all environment variables of the system
        </DD>
        <DT>
          <TT>.hash&nbsp;&nbsp; ( -- )</TT>
        </DT>
        <DD>
          List hash table performance statistics of the wordlist that's first in the search order
        </DD>
        <DT>
          <TT>.ver&nbsp;&nbsp; ( -- )</TT>
        </DT>
        <DD>
          Display ficl version ID
        </DD>
        <DT>
          <TT>&gt;name&nbsp;&nbsp; ( xt -- c-addr u )</TT>
        </DT>
        <DD>
          Convert a word's execution token into the address and length of its name
        </DD>
        <DT>
          <TT>body&gt;&nbsp;&nbsp; ( a-addr -- xt )</TT>
        </DT>
        <DD>
          Reverses the effect of <TT>CORE</TT> word <TT>&gt;body</TT> (converts a parameter field address to an execution token)
        </DD>
        <DT>
          <TT>compile-only</TT>
        </DT>
        <DD>
          Mark the most recently defined word as being executable only while in compile state. Many <TT>immediate</TT> words have this property.
        </DD>
        <DT>
          <TT>empty&nbsp;&nbsp; ( -- )</TT>&nbsp;
        </DT>
        <DD>
          Empty the parameter stack
        </DD>
        <DT>
          <TT>endif</TT>
        </DT>
        <DD>
          Synonym for <TT>THEN</TT>
        </DD>
        <DT>
          <A name="last-word"></A><TT>last-word&nbsp;&nbsp; ( -- xt )</TT>
        </DT>
        <DD>
          Pushes the xt address of the most recently defined word. This applies to colon definitions, constants, variables, and words that use <TT>create</TT>. You can print the name of the most
          recently defined word with&nbsp;
        </DD>
        <DD>
          <B><TT>last-word &gt;name type</TT>&nbsp;</B>
        </DD>
        <DT>
          <TT>parse-word&nbsp;&nbsp; ( &lt;spaces&gt;name -- c-addr u )</TT>
        </DT>
        <DD>
          Skip leading spaces and parse name delimited by a space. c-addr is the address within the input buffer and u is the length of the selected string. If the parse area is empty, the resulting
          string has a zero length. (From the Standard)
        </DD>
        <DT>
          <A name="qfetch"></A><TT>q@&nbsp;&nbsp; ( addr -- x )</TT>
        </DT>
        <DD>
          Fetch a 32 bit quantity from the specified address
        </DD>
        <DT>
          <A name="qbang"></A><TT>q!&nbsp;&nbsp; ( x addr -- )</TT>
        </DT>
        <DD>
          Store a 32 bit quantity to the specified address&nbsp;
        </DD>
        <DT>
          <TT>w@&nbsp;&nbsp; ( addr -- x )</TT>
        </DT>
        <DD>
          Fetch a 16 bit quantity from the specified address
        </DD>
        <DT>
          <TT>w!&nbsp;&nbsp; ( x addr -- )</TT>
        </DT>
        <DD>
          Store a 16 bit quantity to the specified address (the low 16 bits of the given value)
        </DD>
        <DT>
          <A name="xdot"></A><TT>x.&nbsp;&nbsp; ( x -- )</TT>
        </DT>
        <DD>
          Pop and display the value in hex format, regardless of the current value of <TT>BASE</TT>
        </DD>
      </DL>
      <H3>
        <A name="exficlwin"></A>Extra words defined in testmain.c
      </H3>
      <DL>
        <DT>
          <TT>break&nbsp;&nbsp; ( -- )</TT>
        </DT>
        <DD>
          Does nothing - just a handy place to set a debugger breakpoint
        </DD>
        <DT>
          <TT>cd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( "directory-name&lt;newline&gt;" -- )</TT>
        </DT>
        <DD>
          Executes the Win32 chdir() function, changing the program's logged directory.
        </DD>
        <DT>
          <A name="clock"></A><TT>clock&nbsp;&nbsp; ( -- now )</TT>
        </DT>
        <DD>
          Wrapper for the ANSI C clock() function. Returns the number of clock ticks elapsed since process start.
        </DD>
        <DT>
          <A name="clockspersec"></A><TT>clocks/sec&nbsp;&nbsp; ( -- clocks_per_sec )</TT>
        </DT>
        <DD>
          Pushes the number of ticks in a second as returned by <TT>clock</TT>
        </DD>
        <DT>
          <A name="ficlload"></A><TT>load&nbsp;&nbsp;&nbsp; ( "filename&lt;newline&gt;" -- )</TT>
        </DT>
        <DD>
          Opens the Forth source file specified and loads it one line at a time, like <TT>INCLUDED (FILE)</TT>
        </DD>
        <DT>
          <TT>pwd&nbsp;&nbsp;&nbsp;&nbsp; ( -- )</TT>
        </DT>
        <DD>
          Prints the current working directory as set by <TT>cd</TT>
        </DD>
        <DT>
          <TT>system&nbsp; ( "command&lt;newline&gt;" -- )</TT>
        </DT>
        <DD>
          Issues a command to a shell; implemented with the Win32 system() call.
        </DD>
        <DT>
          <TT>spewhash&nbsp;&nbsp; ( "filename&lt;newline&gt;" -- )</TT>
        </DT>
        <DD>
          Dumps all threads of the current compilation wordlist to the specified text file. This was useful when I thought there might be some point in attempting to optimize the hash function. I no
          longer harbor those illusions.
        </DD>
      </DL>
      <HR>
      <H2>
        <A name="ansinfo"></A>ANS Required Information
      </H2>
      <UL>
        <LI>
          <B>ANS Forth System</B>
        </LI>
        <LI>
          <B>Providing names from the Core Extensions word set&nbsp;</B>
        </LI>
        <LI>
          <B>Providing the Exception word set</B>
        </LI>
        <LI>
          <B>Providing names from the Exception Extensions word set</B>
        </LI>
        <LI>
          <B>Providing the Locals word set&nbsp;</B>
        </LI>
        <LI>
          <B>Providing the Locals Extensions word set&nbsp;</B>
        </LI>
        <LI>
          <B>Providing the Memory Allocation word set</B>
        </LI>
        <LI>
          <B>Providing the Programming-Tools word set</B>
        </LI>
        <LI>
          <B>Providing names from the Programming-Tools Extensions word set</B>
        </LI>
        <LI>
          <B>Providing the Search-Order word set</B>
        </LI>
        <LI>
          <B>Providing the Search-Order Extensions word set</B>
        </LI>
      </UL>
      <H3>
        Implementation-defined Options
      </H3>
      The implementation-defined items in the following list represent characteristics and choices left to the discretion of the implementor, provided that the requirements of the Standard are met. A
      system shall document the values for, or behaviors of, each item.&nbsp; 
      <UL>
        <LI>
          <B>aligned address requirements (3.1.3.3 Addresses);</B>&nbsp;
          <BR>
          System dependent. You can change the default address alignment by defining FICL_ALIGN on your compiler's command line. The default value is set to 2 in sysdep.h. This
          causes dictionary entries and <TT>ALIGN</TT> and <TT>ALIGNED</TT> to align on 4 byte boundaries. To align on <B>2<SUP>n</SUP></B> byte boundaries, set FICL_ALIGN to <B>n</B>.&nbsp;
        </LI>
        <LI>
          <B>behavior of 6.1.1320 EMIT for non-graphic characters</B>;&nbsp;
          <BR>
          Depends on target system, C runtime library, and your implementation of ficlTextOut().&nbsp;
        </LI>
        <LI>
          <B>character editing of 6.1.0695 ACCEPT and 6.2.1390 EXPECT</B>;&nbsp;
          <BR>
          None implemented in the versions supplied in words.c. Because ficlExec() is supplied a text buffer externally, it's up to your system to define how that buffer will
          be obtained.
        </LI>
        <LI>
          <B>character set (3.1.2 Character types, 6.1.1320 EMIT, 6.1.1750 KEY)</B>;&nbsp;
          <BR>
          Depends on target system and implementation of ficlTextOut(). 
        </LI>
        <LI>
          <B>character-aligned address requirements (3.1.3.3 Addresses)</B>;&nbsp;
          <BR>
          Ficl characters are one byte each. There are no alignment requirements.
        </LI>
        <LI>
          <B>character-set-extensions matching characteristics (3.4.2 Finding definition names)</B>;&nbsp;
          <BR>
          No special processing is performed on characters beyond case-folding. Therefore, extended characters will not match their unaccented counterparts.
        </LI>
        <LI>
          <B>conditions under which control characters match a space delimiter (3.4.1.1 Delimiters)</B>;&nbsp;
          <BR>
          Ficl uses the Standard C function isspace() to distinguish space characters. The rest is up to your library vendor.&nbsp;
        </LI>
        <LI>
          <B>format of the control-flow stack (3.2.3.2 Control-flow stack)</B>;&nbsp;
          <BR>
          Uses the data stack
        </LI>
        <LI>
          <B>conversion of digits larger than thirty-five (3.2.1.2 Digit conversion)</B>;&nbsp;
          <BR>
          The maximum supported value of <TT>BASE</TT> is 36. Ficl will assertion fail in function ltoa of vm.c if the base is found to be larger than 36 or smaller than 2.
          There will be no effect if NDEBUG is defined, however, other than possibly unexpected behavior.&nbsp;
        </LI>
        <LI>
          <B>display after input terminates in 6.1.0695 ACCEPT and 6.2.1390 EXPECT</B>;&nbsp;
          <BR>
          Target system dependent
        </LI>
        <LI>
          <B>exception abort sequence (as in 6.1.0680 ABORT")</B>;&nbsp;
          <BR>
          Does <TT>ABORT</TT>&nbsp;
        </LI>
        <LI>
          <B>input line terminator (3.2.4.1 User input device)</B>;<FONT color="#FF0000">&nbsp;</FONT>
           <BR>
           Target system dependent (implementation of outer loop that calls ficlExec)&nbsp;
        </LI>
        <LI>
          <B>maximum size of a counted string, in characters (3.1.3.4 Counted strings, 6.1.2450 WORD)</B>;&nbsp;
           <BR>
           255&nbsp;
        </LI>
        <LI>
          <B>maximum size of a parsed string (3.4.1 Parsing)</B>;&nbsp;
           <BR>
           Limited by available memory and the maximum unsigned value that can fit in a CELL (2<SUP>32</SUP>-1).&nbsp;
        </LI>
        <LI>
          <B>maximum size of a definition name, in characters (3.3.1.2 Definition names)</B>;&nbsp;
           <BR>
           Ficl stores the first 31 characters of a definition name.
        </LI>
        <LI>
          <B>maximum string length for 6.1.1345 ENVIRONMENT?, in characters</B>;&nbsp;
           <BR>
           Same as maximum definition name length&nbsp;
        </LI>
        <LI>
          <B>method of selecting 3.2.4.1 User input device</B>;&nbsp;
           <BR>
           None supported. This is up to the target system&nbsp;
        </LI>
        <LI>
          <B>method of selecting 3.2.4.2 User output device</B>;&nbsp;
           <BR>
           None supported. This is up to the target system&nbsp;
        </LI>
        <LI>
          <B>methods of dictionary compilation (3.3 The Forth dictionary)</B>;&nbsp;
        </LI>
        <LI>
          <B>number of bits in one address unit (3.1.3.3 Addresses)</B>;&nbsp;
           <BR>
           Target system dependent. Ficl generally supports processors that can address 8 bit quantities, but there is no dependency that I'm aware of.&nbsp;
        </LI>
        <LI>
          <B>number representation and arithmetic (3.2.1.1 Internal number representation)</B>;&nbsp;
          <BR>
          System dependent. Ficl represents a CELL internally as a union that can hold INT32 (a signed 32 bit scalar value), UNS32 (32 bits unsigned), and an untyped pointer. No specific byte
          ordering is assumed.&nbsp;
        </LI>
        <LI>
          <B>ranges for n, +n, u, d, +d, and ud (3.1.3 Single-cell types, 3.1.4 Cell-pair types)</B>;&nbsp;
          <BR>
          Assuming a 32 bit implementation, range for signed single-cell values is -2<SUP>31</SUP>..2<SUP>31</SUP>-1. Range for unsigned single cell values is 0..2<SUP>32</SUP>-1. Range for signed
          double-cell values is -2<SUP>63</SUP>..2<SUP>63</SUP>-1. Range for unsigned single cell values is 0..2<SUP>64</SUP>-1.&nbsp;
        </LI>
        <LI>
          <B>read-only data-space regions (3.3.3 Data space)</B>;
          <BR>
          None&nbsp;
        </LI>
        <LI>
          <B>size of buffer at 6.1.2450 WORD (3.3.3.6 Other transient regions)</B>;&nbsp;
          <BR>
          Default is 255. Depends on the setting of nPAD in ficl.h.&nbsp;
        </LI>
        <LI>
          <B>size of one cell in address units (3.1.3 Single-cell types)</B>;&nbsp;
          <BR>
          System dependent, generally four.
        </LI>
        <LI>
          <B>size of one character in address units (3.1.2 Character types)</B>;&nbsp;
           <BR>
           System dependent, generally one.
        </LI>
        <LI>
          <B>size of the keyboard terminal input buffer (3.3.3.5 Input buffers)</B>;&nbsp;
           <BR>
           This buffer is supplied by the host program. Ficl imposes no practical limit.&nbsp;
        </LI>
        <LI>
          <B>size of the pictured numeric output string buffer (3.3.3.6 Other transient regions)</B>;&nbsp;
           <BR>
           Default is 255 characters. Depends on the setting of nPAD in ficl.h.&nbsp;
        </LI>
        <LI>
          <B>size of the scratch area whose address is returned by 6.2.2000 PAD (3.3.3.6 Other transient regions)</B>;&nbsp;
           <BR>
           Not presently supported&nbsp;
        </LI>
        <LI>
          <B>system case-sensitivity characteristics (3.4.2 Finding definition names)</B>;&nbsp;
          <BR>
          Ficl is not case sensitive&nbsp;
        </LI> 
        <LI>
          <B>system prompt (3.4 The Forth text interpreter, 6.1.2050 QUIT)</B>;&nbsp;
          <BR>
          "ok&gt;"&nbsp;
        </LI>
        <LI>
          <B>type of division rounding (3.2.2.1 Integer division, 6.1.0100 */, 6.1.0110 */MOD, 6.1.0230 /, 6.1.0240 /MOD, 6.1.1890 MOD)</B>;&nbsp;
           <BR>
           Symmetric rounding (toward zero)&nbsp;
        </LI>
        <LI>
          <B>values of 6.1.2250 STATE when true</B>;&nbsp;
          <BR>
          One (no others)&nbsp;
        </LI>
        <LI>
          <B>values returned after arithmetic overflow (3.2.2.2 Other integer operations)</B>;&nbsp;
           <BR>
           System dependent. Ficl makes no special checks for overflow.&nbsp;
        </LI>
        <LI>
          <B>whether the current definition can be found after 6.1.1250 DOES&gt; (6.1.0450 :)</B>.&nbsp;
           <BR>
           No. Definitions are unsmudged after ; only, and only then if no control structure matching problems have been detected.&nbsp;
        </LI>
      </UL>
      <H3>
        Ambiguous Conditions
      </H3>
      A system shall document the system action taken upon each of the general or specific ambiguous conditions identified in this Standard. See 3.4.4 Possible actions on an ambiguous
      condition.&nbsp; 
      <P>
        The following general ambiguous conditions could occur because of a combination of factors:&nbsp;
      </P>
      <UL>
        <LI>
          <B>a name is neither a valid definition name nor a valid number during text interpretation (3.4 The Forth text interpreter)</B>;&nbsp;
           <BR>
           Ficl does <TT>ABORT</TT> and prints the name followed by " not found".&nbsp;
        </LI>
        <LI>
          <B>a definition name exceeded the maximum length allowed (3.3.1.2 Definition names)</B>;&nbsp;
          <BR>
          Ficl stores the first 31 characters of the definition name, and uses all characters of the name in computing its hash code. The actual length of the name, up to 255
          characters, is stored in the definition's length field.&nbsp;
        </LI>
        <LI>
          <B>addressing a region not listed in 3.3.3 Data Space</B>;&nbsp;
           <BR>
           No problem: all addresses in ficl are absolute. You can reach any address in Ficl's address space.
        </LI>
        <LI>
          <B>argument type incompatible with specified input parameter, e.g., passing a flag to a word expecting an n (3.1 Data types)</B>;&nbsp;
           <BR>
           Ficl makes no check for argument type compatibility. Effects of a mismatch vary widely depending on the specific problem and operands.&nbsp;
        </LI>
        <LI>
          <B>attempting to obtain the execution token, (e.g., with 6.1.0070 ', 6.1.1550 FIND, etc.) of a definition with undefined interpretation semantics</B>;&nbsp;
          <BR>
          Ficl returns a valid token, but the result of executing that token while interpreting may be undesirable.
        </LI>
        <LI>
          <B>dividing by zero (6.1.0100 */, 6.1.0110 */MOD, 6.1.0230 /, 6.1.0240 /MOD, 6.1.1561 FM/MOD, 6.1.1890 MOD, 6.1.2214 SM/REM, 6.1.2370 UM/MOD, 8.6.1.1820 M*/)</B>;
           <BR>
           Results are target procesor dependent. Generally, Ficl makes no check for divide-by-zero. The target processor will probably throw an exception.&nbsp;
        </LI>
        <LI>
          <B>insufficient data-stack space or return-stack space (stack overflow)</B>;&nbsp;
           <BR>
           With FICL_ROBUST (sysdep.h) set &gt;= 2, most parameter stack operations are checked for underflow and overflow. Ficl does not check the return stack.&nbsp;
        </LI>
        <LI>
          <B>insufficient space for loop-control parameters</B>;&nbsp;
          <BR>
          No check - Evil results.&nbsp;
        </LI>
        <LI>
          <B>insufficient space in the dictionary</B>;&nbsp;
          <BR>
          Ficl generates an error message if the dictionary is too full to create a definition header. It checks <TT>ALLOT</TT> as well, but it is possible to make an unchecked
          allocation request that overflows the dictionary.&nbsp;
        </LI>
        <LI>
          <B>interpreting a word with undefined interpretation semantics</B>;&nbsp;
          <BR>
          Ficl protects all ANS Forth words with undefined interpretation semantics from being executed while in interpret state. It is possible to defeat this protection using
          ' (tick) and <TT>EXECUTE</TT>, though.&nbsp;
        </LI>
        <LI>
          <B>modifying the contents of the input buffer or a string literal (3.3.3.4 Text-literal regions, 3.3.3.5 Input buffers)</B>;&nbsp;
          <BR>
          Varies depending on the nature of the buffer. The input buffer is supplied by ficl's host function, and may reside in read-only memory. If so, writing the input
          buffer can ganerate an exception. String literals are stored in the dictionary, and are writable.&nbsp;
        </LI>
        <LI>
          <B>overflow of a pictured numeric output string</B>;
          <BR>
          In the unlikely event you are able to construct a pictured numeric string of more than 255 characters, the system will be corrupted unpredictably. The buffer area that holds pictured
          numeric output is at the end of the virtual machine. Whatever is mapped after the offending VM in memory will be trashed, along with the heap structures that contain it.&nbsp;
        </LI>
        <LI>
          <B>parsed string overflow</B>;
           <BR>
           Ficl does not copy parsed strings unless asked to. Ordinarily, a string parsed from the input buffer during normal interpretation is left in-place, so there is no possibility of overflow.
          If you ask to parse a string into the dictionary, as in <TT>SLITERAL</TT>, you need to have enough room for the string, otherwise bad things may happen. This is not usually a problem.&nbsp;
        </LI>
        <LI>
          <B>producing a result out of range, e.g., multiplication (using *) results in a value too big to be represented by a single-cell integer (6.1.0090 *, 6.1.0100 */, 6.1.0110 */MOD, 6.1.0570
          &gt;NUMBER, 6.1.1561 FM/MOD, 6.1.2214 SM/REM, 6.1.2370 UM/MOD, 6.2.0970 CONVERT, 8.6.1.1820 M*/)</B>;&nbsp;
           <BR>
           Value will be truncated to fit in a single cell.&nbsp;
        </LI>
        <LI>
          <B>reading from an empty data stack or return stack (stack underflow)</B>;&nbsp;
          <BR>
          Most stack underflows are detected and prevented if FICL_ROBUST (sysdep.h) is set to 2 or greater. Otherwise, the stack pointer and size are likely to be
          trashed.&nbsp;
        </LI>
        <LI>
          <B>unexpected end of input buffer, resulting in an attempt to use a zero-length string as a name</B>;&nbsp;
           <BR>
           Ficl returns for a new input buffer until a non-empty one is supplied.&nbsp;
        </LI>
      </UL>
      The following specific ambiguous conditions are noted in the glossary entries of the relevant words:&nbsp; 
      <UL>
        <LI>
          <B>&gt;IN greater than size of input buffer (3.4.1 Parsing)</B>
           <BR>
           Bad Things occur - unpredictable bacause the input buffer is supplied by the host program's outer loop.&nbsp;
        </LI>
        <LI>
          <B>6.1.2120 RECURSE appears after 6.1.1250 DOES&gt;</B>
           <BR>
           It finds the address of the definition before <TT>DOES&gt;</TT>
        </LI>
        <LI>
          <B>argument input source different than current input source for 6.2.2148 RESTORE-INPUT</B>
           <BR>
           Not implemented&nbsp;
        </LI>
        <LI>
          <B>data space containing definitions is de-allocated (3.3.3.2 Contiguous regions)</B>
           <BR>
           This is OK until the cells are overwritten with something else. The dictionary maintains a hash table, and the table must be updated in order to de-allocate words without corruption.&nbsp;
        </LI>
        <LI>
          <B>data space read/write with incorrect alignment (3.3.3.1 Address alignment)</B>
           <BR>
           Target processor dependent. Consequences include: none (Intel), address error exception (68K).&nbsp;
        </LI>
        <LI>
          <B>data-space pointer not properly aligned (6.1.0150 ,, 6.1.0860 C,)</B>
           <BR>
           See above on data space read/write alignment&nbsp;
        </LI>
        <LI>
          <B>less than u+2 stack items (6.2.2030 PICK, 6.2.2150 ROLL)</B>
           <BR>
           Ficl detects a stack underflow and reports it, executing <TT>ABORT,</TT> as long as FICL_ROBUST is two or larger.&nbsp;
        </LI>
        <LI>
          <B>loop-control parameters not available ( 6.1.0140 +LOOP, 6.1.1680 I, 6.1.1730 J, 6.1.1760 LEAVE, 6.1.1800 LOOP, 6.1.2380 UNLOOP)</B>
          <BR>
          Loop initiation words are responsible for checking the stack and guaranteeing that the control parameters are pushed. Any underflows will be detected early if FICL_ROBUST is set to two or
          greater. Note however that Ficl only checks for return stack underflows at the end of each line of text.&nbsp;
        </LI>
        <LI>
          <B>most recent definition does not have a name (6.1.1710 IMMEDIATE)</B>
           <BR>
           No problem.&nbsp;
        </LI>
        <LI>
          <B>name not defined by 6.2.2405 VALUE used by 6.2.2295 TO</B>
           <BR>
           Ficl's version of <TT>TO</TT> works correctly with <TT>VALUE</TT>s, <TT>CONSTANT</TT>s and <TT>VARIABLE</TT>s.&nbsp;
        </LI>
        <LI>
          <B>name not found (6.1.0070 ', 6.1.2033 POSTPONE, 6.1.2510 ['], 6.2.2530 [COMPILE])</B>
           <BR>
           Ficl prints an error message and does <TT>ABORT</TT>
        </LI>
        <LI>
          <B>parameters are not of the same type (6.1.1240 DO, 6.2.0620 ?DO, 6.2.2440 WITHIN)</B>
           <BR>
           No check. Results vary depending on the specific problem.&nbsp;
        </LI>
        <LI>
          <B>6.1.2033 POSTPONE or 6.2.2530 [COMPILE] applied to 6.2.2295 TO</B>
           <BR>
           The word is postponed correctly.&nbsp;
        </LI>
        <LI>
          <B>string longer than a counted string returned by 6.1.2450 WORD</B>
           <BR>
           Ficl stores the first FICL_STRING_MAX-1 chars in the destination buffer. (The extra character is the trailing space required by the standard. Yuck.)&nbsp;
        </LI>
        <LI>
          <B>u greater than or equal to the number of bits in a cell (6.1.1805 LSHIFT, 6.1.2162 RSHIFT)</B>
           <BR>
           Depends on target process or and C runtime library implementations of the &lt;&lt; and &gt;&gt; operators on unsigned values. For I386, the processor appears to shift modulo the number of
          bits in a cell.&nbsp;
        </LI>
        <LI>
          <B>word not defined via 6.1.1000 CREATE (6.1.0550 &gt;BODY, 6.1.1250 DOES&gt;)</B>
        </LI>
        <LI>
           <B>words improperly used outside 6.1.0490 &lt;# and 6.1.0040 #&gt; (6.1.0030 #, 6.1.0050 #S, 6.1.1670 HOLD, 6.1.2210 SIGN)</B>
           <BR>
           Don't. <TT>CREATE</TT> reserves a field in words it builds for <TT>DOES&gt;</TT>to fill in. If you use <TT>DOES&gt;</TT> on a word not made by <TT>CREATE</TT>, it will overwrite the first
          cell of its parameter area. That's probably not what you want. Likewise, pictured numeric words assume that there is a string under construction in the VM's scratch buffer. If that's not
          the case, results may be unpleasant.
        </LI>
      </UL>
      <H3>
        Locals Implementation-defined options
      </H3>
      <UL>
        <LI>
          <B>maximum number of locals in a definition (13.3.3 Processing locals, 13.6.2.1795 LOCALS|)</B>
          <BR>
           Default is 16. Change by redefining FICL_MAX_LOCALS, defined in sysdep.h
        </LI>
      </UL>
      <H3>
        Locals Ambiguous conditions
      </H3>
      <UL>
        <LI>
          <B>executing a named local while in interpretation state (13.6.1.0086 (LOCAL))</B>
          <BR>
           Locals can be found in interpretation state while in the context of a definition under construction. Under these circumstances, locals behave correctly. Locals are not visible at all
          outside the scope of a definition.&nbsp;
        </LI>
        <LI>
          <B>name not defined by VALUE or LOCAL (13.6.1.2295 TO)</B>
          <BR>
           See the CORE ambiguous conditions, above (no change)
        </LI>
      </UL>
      <H3>
        Programming Tools Implementation-defined options
      </H3>
      <UL>
        <LI>
          <B>source and format of display by 15.6.1.2194 SEE</B>
          <BR>
           SEE de-compiles definitions from the dictionary. Because Ficl words are threaded by their header addresses, it is very straightforward to print the name and other characteristics of words
          in a definition. Primitives are so noted. Colon definitions are decompiled, but branch target labels are not reconstructed. Literals and string literals are so noted, and their contents
          displayed.
        </LI>
      </UL>
      <H3>
        Search Order Implementation-defined options
      </H3>
      <UL>
        <LI>
          <B>maximum number of word lists in the search order (16.3.3 Finding definition names, 16.6.1.2197 SET-ORDER)</B>&nbsp;
          <BR>
           Defaults to 16. Can be changed by redefining FICL_DEFAULT_VOCS, declared in sysdep.h&nbsp;
        </LI>
        <LI>
          <B>minimum search order (16.6.1.2197 SET-ORDER, 16.6.2.1965 ONLY)</B>&nbsp;
          <BR>
           Equivalent to <TT>FORTH-WORDLIST 1 SET-ORDER</TT>
        </LI>
      </UL>
      <H3>
        Search Order Ambiguous conditions
      </H3>
      <UL>
        <LI>
          <B>changing the compilation word list (16.3.3 Finding definition names)</B>
          <BR>
           Ficl stores a link to the current definition independently of the compile wordlist while it is being defined, and links it into the compile wordlist only after the definition completes
          successfully. Changing the compile wordlist mid-definition will cause the definition to link into the <I>new</I> compile wordlist.&nbsp;
        </LI>
        <LI>
          <B>search order empty (16.6.2.2037 PREVIOUS)</B>
          <BR>
           Ficl prints an error message if the search order underflows, and resets the order to its default state.&nbsp;
        </LI>
        <LI>
          <B>too many word lists in search order (16.6.2.0715 ALSO)</B>
          <BR>
           Ficl prints an error message if the search order overflows, and resets the order to its default state.
        </LI>
      </UL>
      </div>
    </main>

    <footer class="site-footer">
      <div class="wrap footer-grid">
        <div>Ficl - Forth Inspired Command Language</div>
        <div>Questions or contributions: <a href="https://sourceforge.net/u/jsadler/profile/">John Sadler</a></div>
      </div>
    </footer>
  </body>
</html>
